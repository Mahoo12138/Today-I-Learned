`Object3D` 是 Three.js 场景图中所有对象的基类，**管理对象的空间变换、父子关系、事件交互**。

场景图结构：Three.js 使用树状结构（场景图）组织对象，类似 DOM 树。每个 Object3D 可以包含子对象，形成层级关系：

```js
scene.add(camera);  // 场景是根对象
camera.add(light);  // 相机可以包含光源
group.add(mesh1, mesh2); // Group 用于组合对象
```

**为什么需要场景图**：层级结构允许**局部坐标系**的复用。例如，一个旋转的父对象会导致所有子对象跟随旋转。

## 位置、旋转、缩放

### position



### rotation

`mesh.rotation` 是一个 **Euler（欧拉角）对象**，表示用三个角度（绕 X、Y、Z 轴）来描述旋转。比如：

```js
mesh.rotation.y = Math.PI * 0.25 
mesh.rotation.x = Math.PI * 0.5 
mesh.rotation.z = Math.PI * 0.25
```

注意，上述代码只是**依次设置了三个角度的值**，但 **真正控制旋转顺序的是这个属性** `mesh.rotation.order`。

Three.js 默认的顺序是：

```
console.log(mesh.rotation.order); // 默认是 "XYZ"
XYZ → 先绕 X 轴旋转，再绕 Y，再绕 Z
```

使用 `rotation.reorder` 重新设置 ：

```
mesh.rotation.reorder('ZYX')	// 重新设置顺序
```

**欧拉角的旋转顺序不同，最终结果也会不同！**在最终渲染的时候，会根据这个顺序来「组合这些角度」形成旋转矩阵（或者四元数）。

### quaternion

四元数（quaternion）是一种用来表示**旋转**的数学工具，跟欧拉角（rotation）或旋转矩阵一样，都是旋转的**一种表示方式**。

四元数是 (x, y, z, w)，带一个额外的分量 `w`。这个结构看起来复杂，但它可以优雅地避免一些欧拉角的缺陷。

```js
quaternion = { x, y, z, w }
```

Three.js 内部其实 **全部用四元数做最终旋转计算！**，操作 `.rotation` 设置欧拉角时，Three.js 会自动将其转为 `.quaternion`。

四元数是扩展自复数的数学结构，可以表示**三维空间中的旋转**，格式如下：

```
Q = w + xi + yj + zk
```

它是如何表达旋转的呢？

实际上，上述式子定义一个绕单位轴 **u = (x, y, z)** 旋转角度 θ 的四元数：

```
Q = {
  x: u.x * sin(θ/2),
  y: u.y * sin(θ/2),
  z: u.z * sin(θ/2),
  w: cos(θ/2)
}
```

也就是说，四元数用的是 **“轴角”表示法** 的变种：

- **方向用向量 `u` 表示**
- **旋转角度 θ 被编码进了正弦和余弦里**

然后这个四元数就可以用于**旋转任意向量**，通过一种叫做：$v' = Q * v * Q⁻¹$ 的数学变换（v 和 Q 都是四元数形式）来计算。

这个乘法顺序正是为什么四元数旋转是**稳定、无抖动、无万向锁**的。

> 总结一句话：**四元数就是把“旋转轴 + 旋转角”打包进了一个安全、平滑、稳定的数学结构中。**
