# The Evolution of JavaScript Modularity

When [Brendan Eich](https://github.com/BrendanEich) was designing the first version of JavaScript, he probably had no idea how his project will evolve during the last twenty years. At the moment there are already six major releases of specification of the language and work on its improvement still continues.

Let's be honest, JavaScript has never been the perfect programming language. One of the weaknesses of JS was modularity, to put it more clear, its absence. Indeed why do you need to care about isolation of the code and dependencies, when you use scripting language only for animations of the falling snowflakes on the page or for the form validation, when everything can live and interact in the same global scope?

With the time JavaScript has transformed into a general purpose language, as it began to be used to build a complex applications in the various environments (browser, mobile, server, IoT). The old approaches of the interaction of components of the program through the global scope became unreliable, because the increasing amount of the code tend to make your application too fragile. That is why for simplification of creation JavaScript applications there were created various realizations of modularity.

In this article, which is a result of communication with members of TC39, the developers of the different frameworks, reading source code, blogs and books, we will look at the following approaches/formats: Namespace, Module, Detached Dependency Definitions, Sandbox, Dependency Injection, CommonJS, AMD, UMD, Labeled Modules, YModules, ES2015 Modules. And meanwhile we will restore historical context of their emergence.

## Defining the Used Terms

The modularity solves [next issues](http://blog.calyptus.eu/seb/2011/10/choosing-a-javascript-module-syntax/): code isolation, dependency definition between modules, and delivering of the code into execution environment. Some approaches solved only one or two issues, we will name this solutions as "patterns". Some approaches solved all of three, we will name them as “module systems”.

We will name particular structure of the source code with definitions of exported entities (objects, functions etc.) and definitions of imported entities as "module format".

The "Detached Dependency Definition" (DDD for short) means such approaches of describing dependencies which can be used independently from the module systems.

## A Little More About Problems

Before delve into the world of modularity let’s take a closer look at the problems which we will try to solve.

### The Name Collision

From the moment of its appearance JavaScript has used the global object window as a storage for all variables defined without the `var` keyword. In 1995-1999 it was very convenient, because JavaScript code tended to solve small tasks that hadn't required a lot of lines of code. But when the codebase of applications had became large this feature of the language began to lead to nasty errors because of the name collisions. Let’s look at this example:

```
// file greeting.js
var helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

function writeHello(lang) {
    document.write(helloInLang[lang]);
}

// file hello.js
function writeHello() {
    document.write('The script is broken');
}
```



When we place the script `greeting.js` on the page and after it `hello.js` there will be conflict, that is instead of the greeting we will get the message "The script is broken" in this particular case.

It is obvious that in the large projects this can cause a lot of headaches. Moreover you cannot be sure that the third-party scripts on the page won't break anything in your app.

### The Support for Large Codebases

An another inconvenient moment of JavaScript for the building of large applications is the need to explicitly specify a plugged-in scripts using the `script` tag in the most common ES5 browser environments.

If you care about the fact that the source code of application should be maintainable, then you need to split it into independent parts. Because of this the amount of the files may be a really large. With a large number of files the manual control of the scripts (i.e. the placing scripts on the page via the script tag) becomes very tedious, because firstly you have to remember to put necessary scripts in the page and secondly preserve the proper order of the `script` tags so that all dependencies between files has been resolved.

## Directly Defined Dependencies (1999)

The first attempt to bring the structure of the modules into JavaScript and the first implementation of the detached dependency definition was pattern "Directly Defined Dependencies". This pattern firstly was [used](https://twitter.com/erikarvidsson/status/825403889969033216) by [Erik Arvidsson](https://github.com/arv) (member of TC39 at the present moment) in 1999 year.

At that time Erik worked at a startup developing a platform for running gui applications in a browser, it was called WebOS (note that this is not webOS, which was developed by Palm). WebOS was a proprietary platform, so I did not manage to get its source code. Therefore we look at the implementation of this pattern using Dojo Toolkit, which was developed by [Alex Russell](https://github.com/slightlyoff) and [Dylan Schiemann](https://github.com/dylans) in 2004.

The gist of directly defined dependencies lied in the getting of the code of the modules (in terms of the Dojo - resources) via explicit invocation of the function `dojo.require` (which is also used to initialise the loaded module). That is in this approach the dependencies were defined directly in the code at those places, where they should to be used.

Let's revise our example using Dojo 1.6:

```
// file greeting.js
dojo.provide("app.greeting");

app.greeting.helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

app.greeting.sayHello = function (lang) {
    return app.greeting.helloInLang[lang];
};

// file hello.js
dojo.provide("app.hello");

dojo.require('app.greeting');

app.hello = function(x) {
    document.write(app.greeting.sayHello('es'));
};
```



Here we see that modules are defined using the function `dojo.provide`, and the process of getting of the code of the module starts when you use `dojo.require`. It is a fairly simple approach that was used in the Dojo up to version 1.7; Google Closure Library uses it to this day.

## The Namespace Pattern (2002)

For solving the issue with name collisions you may use special code conventions. For example you can add particular prefix to all variables and functions: `myApp_`: myApp_address, myApp_validateUser(). Also you can use the fact that functions in JavaScript are first class citizens, i.e. you can assign them to variables, to properties of objects and return them from other functions. Therefore you can create objects with properties-methods similar to objects document and window (document.write(), window.alert()).

The first significant project that took advantage of this opportunity was a library of ui elements Bindows. Bindows was created by already familiar to us Erik Arvidsson in 2002. Instead of using prefixes in the name of functions and variables, he used a global object whose properties contained the data and logic of the library. That fact has greatly reduced the pollution of the global scope. The pattern for that code organisation is known now as the "namespace" (the Namespace Pattern).

If we apply this idea to our example we get something like this:

```
// file app.js
var app = {};

// file greeting.js
app.helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

// file hello.js
app.writeHello = function (lang) {
    document.write(app.helloInLang[lang]);
};
```



As we can see the logic and the data resides now in the properties of the object `app`. Thus we don't pollute the global scope but continue to have access to the various parts of the application from different files.

The Namespace Pattern is probably the most known pattern in JavaScript nowadays. The Bindows was the first but after it there was a lot of other frameworks and libraries which organised logic that way for example Dojo (2005), YUI (2005). Also it should be noted that Erik does not consider himself as the author of this pattern, but [he couldn’t remember](https://twitter.com/erikarvidsson/status/819368206984826880) particular project he was inspired by.

## The Module Pattern (2003)

The Namespace gave some sort of order to the code organisation. But it was evident that it’s not enough, as there was no solution for the isolation of code and data yet.

The pioneer in the solution of this problem is the Module pattern. Its main idea is encapsulating data and code with a closure and providing access to them through methods accessible from the outside. Here is a basic example of this type of pattern:

```
var greeting = (function () {
    var module = {};

    var helloInLang = {
        en: 'Hello world!',
        es: '¡Hola mundo!',
        ru: 'Привет мир!'
    };

    module.getHello = function (lang) {
        return helloInLang[lang];
    };

    module.writeHello = function (lang) {
        document.write(module.getHello(lang))
    };
    
    return module;
}());
```



Here we see the immediately invoked function, which returns a module object, which in turn has a method `getHello` that accesses the object `helloInLang` through the closure. Thus `helloInLang` becomes inaccessible from the outside world and we get an atomic piece of code that can be pasted into any other script without the name collision.

The first use of this approach in the wild was seen in 2003, when Richard Cornford gave an [example](https://groups.google.com/forum/#!msg/comp.lang.javascript/eTzWVa1W_pE/N9lnvRG9WJ8J) of this pattern in the group comp.lang.javascript to illustrate the use of closures. In 2005-2006, the developers of the YUI framework from Yahoo! under the leadership of Douglas Crockford took this approach for their project. But the greatest impetus to its spread was given in 2008 by Douglas, when he described the "Module" in his book JavaScript the Good Parts.

Also there is a good article [JavaScript Module Pattern: In-Depth](http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html). It describes a lot of various ways of implementation of the Module. I recommend to look at it.

## Template Defined Dependencies (2006)

Template defined dependencies is the next pattern in the family of the detached dependency definitions. I was able to find the earliest use of this approach in library [Prototype 1.4](https://github.com/myshov/history-of-javascript/blob/master/old_libs/prototype-1.4.0/src/prototype.js) (2006). But I have a suspicion that this approach was used in the earlier versions of the library also. (If you have access to the earlier versions of prototype let me know).

The development of Prototype started in 2005 by [Sam Stephenson](https://github.com/sstephenson). Prototype was the integral part of Ruby on Rails at that time. Because Sam worked a lot with ruby it is not surprising that for the management of the dependencies he had chosen simple erb templates.

If we try to generalize we can say, that this pattern defines dependencies via inclusion into the target file the special labels. The resolving this labels into actual code can be performed via templating (erb, jinja, smarty), and special build tools, for example, borshik. In contrast to the previous discussed detached dependency definitions patterns, this pattern only works with pre-build step.

Let’s transform our example using this style of dependency definition. For that we will use [borshik](https://github.com/borschik/borschik).

```
// file app.tmp.js

/*borschik:include:../lib/main.js*/

/*borschik:include:../lib/helloInLang.js*/

/*borschik:include:../lib/writeHello.js*/

// file main.js
var app = {};

// file helloInLang.js
app.helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

// file writeHello.js
app.writeHello = function (lang) {
    document.write(app.helloInLang[lang]);
};
```



In the example file app.tmp.js defines the plugged-in scripts and their order. If you will ponder about this example it will be clear that this approach does not fundamentally changes the life of the developer. Instead of using `script` tags you just start to use other labels in js file. Thus we can still forget something or screw up the order of the plugged-in scripts. Therefore the main purpose of this approach is a creating a single file from many other scripts.

## Comment Defined Dependencies (2006)

The comment defined dependencies pattern is also subtype of the detached dependency definitions family. It is very similar to directly defined dependencies, but in this case instead of using some sort of functions we use comments which include the information about all dependencies of the particular module.

An application that use this pattern must be either pre-built (this approach was used in 2006 for [MooTools](https://github.com/mootools/mootools-core/blob/41b0bdedce3adeb921c181145d7c79a8ecbf4763/Plugins/Fxpack.js#L12) which was created by [Valerio Proietti](https://github.com/kamicane)), or dynamically parse downloaded code and resolve dependencies at the runtime. The last approach was used in [LazyJS](https://github.com/bevacqua/lazyjs) which was created by [Nicolás Bevacqua](https://github.com/bevacqua).

Our example will be look like this, if we will rewrite it using this library:

```
// file helloInLang.js
var helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

// file sayHello.js

/*! lazy require scripts/app/helloInLang.js */

function sayHello(lang) {
    return helloInLang[lang];
}

// file hello.js

/*! lazy require scripts/app/sayHello.js */

document.write(sayHello('en'));
```



In a nutshell how the library works. When library downloads files it parses their contents, finds the corresponding comments with dependencies, and eventually downloads them (dependencies), repeating the process of parsing of the downloaded files.

The most well known library which uses this approach MooTools. LazyJS was an interesting experiment but due to the reason that its emergence happened after CommonJS and AMD, LazyJS didn’t get a big attention of developers.

## Externally Defined Dependencies (2007)

Let’s look at the last pattern in the family of DDD. In the externally defined dependencies pattern all dependencies are defined outside of the main context, for example in a configuration file or in a code as an object or an array with the list of dependencies. However there is a phase of preparing. The application during this phase initialises itself with loading all dependencies in the correct order.

The earliest using of this approach, that I managed to find, dates by 2007 in [MooTools 1.1](https://github.com/mootools/mootools-core/blob/d4b15bdd4061d7012748bc2c9da7e70864e12bbb/scripts.json#L14).

In the simplest case our example with using this pattern can be done like this (for this example I will use my own [experimental loader](https://github.com/myshov/eddloader) that use this pattern).

```
// file deps.json
{
    "files": {
        "main.js": ["sayHello.js"],
        "sayHello.js": ["helloInLang.js"],
        "helloInLang.js": []
    }
}

// file helloInLang.js
var helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

// file sayHello.js
function sayHello(lang) {
    return helloInLang[lang];
}

// file main.js
console.log(sayHello('en'));
```



File `deps.json` is the external context in which you define all dependencies. When you run the application the loader receives this file, reads the list of all dependencies that are defined as an array, and then loads and puts them to the page in the correct order.

Nowadays this approach is used in libraries for creating the custom builds. For example such approach uses [lodash](https://github.com/lodash-archive/lodash-cli/blob/master/lib/mapping.js#L386-L1022).

## The Sandbox Pattern (2009)

The developers at Yahoo, who worked on the new module system in YUI3, was solving the problem of using different versions of the library on one page. Prior YUI3 module system of the framework has been implemented using combination of the Module pattern and Namespace. It’s obvious that by using this approach top-level object which contained code of the library could only be one, and therefore simultaneous using of multiple versions of the library was really difficult.

[Adam Moore](https://twitter.com/admo) (one of the developers of YUI3) suggested to use "Sandbox" for a solution to this problem. A simple implementation of modularity using this pattern may look like this:

```
// file sandbox.js
function Sandbox(callback) {
    var modules = [];

    for (var i in Sandbox.modules) {
        modules.push(i);
    }

    for (var i = 0; i < modules.length; i++) {
        this[modules[i]] = Sandbox.modules[modules[i]]();
    }
    
    callback(this);
}

// file greeting.js
Sandbox.modules = Sandbox.modules || {};

Sandbox.modules.greeting = function () {
    var helloInLang = {
        en: 'Hello world!',
        es: '¡Hola mundo!',
        ru: 'Привет мир!'
    };

    return {
        sayHello: function (lang) {
            return helloInLang[lang];
        }
    };
};

// file app.js
new Sandbox(function(box) {
    document.write(box.greeting.sayHello('es'));
});
```



The essence of this approach is that instead of the global object you use a global constructor. The modules can be defined as properties of this constructor.

The "Sandbox" is an interesting solution to the problem of modularity, but besides of YUI3 this pattern didn’t get a lot of attention. If you want to know more about the Sandbox I recommend the article the [Javascript Sandbox Pattern](https://www.kenneth-truyers.net/2016/04/25/javascript-sandbox-pattern/), and the official YUI documentation about [the creation of new modules](https://yuilibrary.com/yui/docs/yui/create.html) of the library.

## Dependency Injection (2009)

In 2004 Martin Fowler introduced the concept of "[dependency injection](https://martinfowler.com/articles/injection.html)" (DI) for the description of the new mechanism of communication the components in Java. The gist is that all dependencies come from outside of the component, therefore the component is not responsible for initialisation its dependencies it only uses them.

Five years later [Miško Hevery](https://github.com/mhevery) a former employee of Sun and Adobe (where he was mainly engaged in development on Java) began to design for his startup a new JavaScript framework, which used dependency injection as the key mechanism of the communication between components. The business idea has not proved its effectiveness, and source code of the framework was opened and introduced to the world at the domain of his startup getangular.com. We all know what happened next. Google has taken under its wing Miško and his project, and now Angular is one of the most known JavaScript frameworks.

Modules in Angular are implemented via the mechanism of Dependency Injection. By the way the modularity is not the primary purpose of DI, about this also clearly Miško says in the answer to [the corresponding question](http://www.alexrothenberg.com/2013/02/11/the-magic-behind-angularjs-dependency-injection.html#comment-806114100).

To illustrate this approach, let's rewrite our example using the first version of Angular (yes, bear in mind that this example is extremely synthetic):

```
// file greeting.js
angular.module('greeter', [])
    .value('greeting', {
        helloInLang: {
            en: 'Hello world!',
            es: '¡Hola mundo!',
            ru: 'Привет мир!'
        },

        sayHello: function(lang) {
            return this.helloInLang[lang];
        }
    });

// file app.js
angular.module('app', ['greeter'])
    .controller('GreetingController', ['$scope', 'greeting', function($scope, greeting) {
        $scope.phrase = greeting.sayHello('en');
    }]);
```



If you will open the page with this example in the browser, then the code will run [magically](http://www.alexrothenberg.com/2013/02/11/the-magic-behind-angularjs-dependency-injection.html) and you will see the result on the page.

At the moment the dependency injection is a key mechanism in such frameworks as [Angular 2](https://github.com/angular/angular) and [Slot](https://github.com/2gis/slot). There are also a large number of libraries that simplify the use of this approach in applications that don’t depend on any framework.

## CommonJS Modules (2009)

Along with the client-side JavaScript engines (in the browsers) even before Node.JS there were [platforms for server-side development](https://en.wikipedia.org/wiki/Comparison_of_server-side_JavaScript_solutions) with JavaScript as the primary language. The server solutions due to the absence of appropriate specifications did not provided a unified API for communication with operating system and an its environment (file system, network, environment variables, and so on), thus creating problems with the code distribution. For example, scripts written for the old Netscape Enterprise Server did not work in Rhino and vice versa.

The turning point occurred in 2009 when an employee of Mozilla [Kevin Dangoor](https://github.com/dangoor) published a [post](http://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/) about the problems with server-side JavaScript with a call to all interested to join an informal Committee to discuss and develop server-side JavaScript API that was called ServerJS. Half a year later ServerJS was renamed to CommonJS because of new concepts that started to be part of the discussions.

Work had begun to boil. The most attention from developers and researchers has been given to [specification](http://www.commonjs.org/specs/modules/1.0/) of the modules - CommonJS Modules (sometimes referred to as CJS or just CommonJS), which eventually was implemented in Node.JS.

As an example of the CommonJS module let's adapt our module by this way:

```
// file greeting.js
var helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

var sayHello = function (lang) {
    return helloInLang[lang];
}

module.exports.sayHello = sayHello;

// file hello.js
var sayHello = require('./lib/greeting').sayHello;
var phrase = sayHello('en');
console.log(phrase);
```



Here we see that for implementation of modularity there are two new entities - `require` and `module` that provide the ability to load a module and to export its interface to the outer world. It is worth noting that neither require nor module are some sort of keywords of the language. In Node.JS we can use them due to the auxiliary function. This function wraps every module before sending it to the JavaScript engine:

```
(function (exports, require, module, __filename, __dirname) {
    // ...
    // Your code injects here!
    // ...
});
```



The CommonJS specification defines only required minimum for the module interoperability in the different environments. It means that CommonJS is open for an extension. For example Node.JS uses this feature by adding property `main` to the `require` function, which points to the `module` if the file that consists this module was executed directly.

Babel also extends `require` during the transpilation of ES2015 Modules (I will talk about this module system in the end of this article) with default export:

```
export default something;
```



Babel transforms such an export into CommonJS module, where default value is exported with corresponding property. Simply speaking you can get something like this as result of transpilation:

```
export.default = something;
```



The bundler Webpack also uses various extensions, for example `require.ensure`, `require.cache`, `require.context`, but their discussion is outside of the context of this article.

CommonJS is the most common module format at the present moment. You can use it not only on the server-side in Node.JS but also on the client-side using [Browserfiy](http://browserify.org/) or [Webpack](https://webpack.js.org/), which can transform set of CommonJS modules into one bundle.

## AMD (2009)

The work on the CommonJS specification has been in full swing, and meanwhile there were [discussions](https://groups.google.com/forum/#!msg/commonjs/nbpX739RQ5o/SdpVQDtx88AJ) in the mailing list about adding into the specification the possibility of asynchronous loading for the modules. The main motivation lied in the fact that this will help to speed up the loading of web applications without some sort of pre-bundling.

The colleague of Kevin another developer from Mozilla [James Burke](https://github.com/jrburke) was one of the most active defenders of asynchronous modularity in all that discussions. James at that time could be an expert, as he was the author of the asynchronous modular system in Dojo Framework 1.7 and also he was developing a loader require.js since 2009.

The basic idea, which James tried to clarify was the fact that loading of the modules should not be synchronous (i.e. loading of the modules one by one in succession); we must use the browser functionality for the parallel loading of the scripts. For implementation of all requirements James had proposed his own format which was called AMD (Asynchronous Module Definition).

If we will rewrite our example using AMD format we will get something like this:

```
// file lib/greeting.js
define(function() {
    var helloInLang = {
        en: 'Hello world!',
        es: '¡Hola mundo!',
        ru: 'Привет мир!'
    };

    return {
        sayHello: function (lang) {
            return helloInLang[lang];
        }
    };
});

// file hello.js
define(['./lib/greeting'], function(greeting) {
    var phrase = greeting.sayHello('en');
    document.write(phrase);
});
```



The file hello.js is the entry point of the program. In this file there is a function `define` that declares a module. The first argument of the function is an array of dependencies. The execution of the code of the module, which is defined as a function in the second argument of `define`, will be launched only after that fact when all dependencies of this module will be loaded. This deferred code execution of the module makes a possibility for the parallel loading of its dependencies.

In 2011 there was the turning point of all this discussions, when James announced the creation of a separate mailing list for coordination all works on AMD, because consensus with the CommonJS group for all this time [had not been reached](https://groups.google.com/forum/#!msg/commonjs/6CdQpDW4loE/Syh_gxvQ5QUJ).

By personal observations I can say that AMD is still relevant for developing of client side applications, however the tendency for the distribution of client-side libraries via npm leads away developers from AMD more and more.

## UMD (2011)

The evident confrontation of module formats began even before when AMD was separated from CommonJS Modules. Already at that time the AMD camp had a lot of developers who liked the minimal entry threshold to the working with modular code. The number of supporters of CommonJS Modules also grew very quickly due to the growing popularity Node.JS and the emergence of Browserify.

So there were two formats, which could not get along with each other. AMD modules couldn't be used in the environments that implements the specification of CommonJS Modules without the code modification. CommonJS modules could not be used with loaders which used AMD as main format (require.js, curl.js) also. It was a bad situation for whole JavaScript ecosystem.

UMD format has been developed for solution of this problem. UMD stands for [Universal Module Definition](https://github.com/umdjs/umd), so this format allows you to use the same module with AMD tools as well as in CommonJS environments.

It was quite difficult to find the original author of this format, so I had to do an investigation. To begin, I turned to the author of UMD repository on GitHub [Addy Osmani](https://github.com/addyosmani), who in turn told me about James Burke and [Kris Kowal](https://github.com/kriskowal). This guys pointed out to [the Q’s repository](https://github.com/kriskowal/q) the first implementation of promises in JavaScript.

Since its inception, the Q library worked in different environments: in the browser (when you put the module on the page via the script tag) and on server-side in Node.JS and Narwhal (CommonJS Modules). James after some time had added the support of AMD into Q. And then Addy had gathered similar patterns in a single repository, which was named UMD. Such a result of adaptation of the code for different module systems is called UMD now.

As an example let's refactor our module greeting.js for the simultaneous support of different environments CommonJS and AMD:

```
(function(define) {
    define(function () {
        var helloInLang = {
            en: 'Hello world!',
            es: '¡Hola mundo!',
            ru: 'Привет мир!'
        };

        return {
            sayHello: function (lang) {
                return helloInLang[lang];
            }
        };
    });
}(
    typeof module === 'object' && module.exports && typeof define !== 'function' ?
    function (factory) { module.exports = factory(); } :
    define
));
```



In the heart of this implementation pattern lies the immediately invoked function expression. That function takes different arguments depending on the environment. The passed argument is the following function if the code is used as a CommonJS module:

```
function (factory) {
    module.exports = factory();
} 
```



If the code is used as an AMD module, the argument of function is `define`. Due this substitution the code can be used in different environments.

Now UMD is such a format that is used by most developers when they need to be able to use their module in the browser or in Node.JS. Many popular libraries support the export into UMD format for example [moment.js](https://github.com/moment/moment/blob/develop/templates/default.js) and [lodash](https://github.com/lodash-archive/lodash-cli/blob/0f68a3195aa37eca8ab13ce2d53ec4bb310edaf1/lib/listing.js#L49-L52).

## Labeled Modules (2012)

Since 2010 TC39 Committee started to work on a new native module system for JavaScript, which was named ES6 Modules at that time. By 2012 it was clear which final look it will take. One of the members of committee [Sebastian Markbåge](https://github.com/sebmarkbage) (also lead developer of React at this moment) had prepared an transitive module format by his own initiative. It was assumed that this format could be used even in ES3 environments and then easily adapted for the new module system. This format was named [Labeled Modules](https://github.com/sebmarkbage/labeled-modules-spec/wiki).

The main idea of this format lies in using of [labels](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). The keywords "import" and "export" is reserved in the language, so they couldn’t be used for labels. Therefore the corresponding synonymous was taken for this purpose. The label "exports" was used for export and the label “require” was used for import.

As always let’s rework our example to show this format in action.

```
// file greeting.js
var helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

exports: var greeting = {
    sayHello: function (lang) {
        return helloInLang[lang];
    }
};

// file hello.js
require: './lib/greeting';
var phrase = greeting.sayHello('es');
document.write(phrase);
```



The example of the config for building of application using Labeled Modules you can take [here](https://github.com/myshov/history-of-javascript/blob/master/4_evolution_of_js_modularity/m_labeled_modules_2012/webpack.config.js).

As we can see, it was a really elegant solution. But due to the fact that in 2012 CommonJS and AMD were a really popular choice for the most developers, the new format couldn't overcome that tough competition. Even though the support of this format [had appeared](https://webpack.github.io/docs/api-in-modules.html) in the first version of webpack, this format had not got a lot of attention in JavaScript community nonetheless.

## YModules (2013)

YModules is a module system that was created at Yandex for solutions of the tasks that neither CommonJS, nor AMD couldn’t solve. There were main requirements for this module system. First is the using of modules with asynchronous nature as transparent as possible, second is the possibility for the redefinition of modules. First requirement was important for implementation of asynchronous API, for example of Yandex.Maps, second was important due to the need of using modules at [levels of definitions in BEM](https://en.bem.info/methodology/key-concepts/#redefinition-level).

The teams of Yandex.Maps and BEM had created the specification for the new module system in 2013. And then it was implemented by [Dmitry Filatov](https://github.com/dfilatov).

Here is the implementation of our example using [YModules](https://github.com/ymaps/modules):

```
// file greeting.js
modules.define('greeting', function(provide) {
    provide({
        helloInLang: {
            en: 'Hello world!',
            es: '¡Hola mundo!',
            ru: 'Привет мир!'
        },

        sayHello: function (lang) {
            return this.helloInLang[lang];
        }
    });
});

// file app.js
modules.require(['greeting'], function(greeting) {
    document.write(greeting.sayHello('ru'));
});
// Result: "Привет мир!"
```



YModules by its structure heavily resembles AMD, but it’s main difference of YModules is an exposing of interface of the module to the consumers via special function `provide` rather than with `return` as in AMD.

This feature allows you to do `provide` from the blocks of an asynchronous code, that is it allows to hide the asynchronous nature of the module from the outside world. For example if we will add into our greeting.js some asynchronous logic (e.g. `setTimeout`) then the whole code using this module will remain untouched:

```
// file greeting.js
modules.define('greeting', function(provide) {
    // postpone of code execution for 1 second
    setTimeout(function () {
        provide({
            helloInLang: {
                en: 'Hello world!',
                es: '¡Hola mundo!',
                ru: 'Привет мир!'
            },

            sayHello: function (lang) {
                return this.helloInLang[lang];
            }
        });
    }, 1000);
});

// file: app.js
modules.require(['greeting'], function(greeting) {
    document.write(greeting.sayHello('ru'));
});
// result: "Привет мир!"
```



As it was said earlier, the main trait of YModules is the possibility of its using with levels of definitions of BEM. Let’s check out how we can to use this feature.

```
// file moduleOnLevel1.js
modules.define('greeting', function(provide) {
    provide({
        helloInLang: {
            en: 'Hello world!',
            es: '¡Hola mundo!',
            ru: 'Привет мир!'
        },

        sayHello: function (lang) {
            return this.helloInLang[lang];
        }
    });
});

// file moduleOnLevel2.js
modules.define('greeting', function(provide, module) {
    // redeclaring of sayHello method
    module.sayHello = function (lang) {
        return module.helloInLang[lang].toUpperCase();
    };
    provide(module);
});

// file app.js
modules.require(['greeting'], function(greeting) {
    document.write(greeting.sayHello('ru'));
});
// Result: "ПРИВЕТ МИР!"
```



If you run this example, then as the result of redefining the `greeting` module the 'sayHello` method will be changed to the new one, and the text of the output message will be converted to uppercase. This is possible due to the fact that in YModules when the module is defined once again, its last argument will contain the previous version of the module.

At the moment YModules is used in the various projects in Yandex. Also it's a main module system in the framework [i-bem.js](https://en.bem.info/platform/i-bem/).

## ES2015 Modules (2015)

Of course the Committee TC39 was watching what was happening in JavaScript world. It was obvious that the time has come for major changes in the language.

The work on the modular system [started](http://wiki.ecmascript.org/doku.php?id=harmony:modules&rev=1300916920) in 2010. The design of this system was created by [Dave Herman](https://github.com/dherman) and [Sam Tobin-Hochstadt](https://github.com/samth/). The work continued in the period of five years. The final design of the [module system](http://www.ecma-international.org/ecma-262/6.0/#sec-modules) has been released with specification ES2015.

By tradition, let's adapt our example to show the specification in action:

```
// file lib/greeting.js
const helloInLang = {
    en: 'Hello world!',
    es: '¡Hola mundo!',
    ru: 'Привет мир!'
};

export const greeting = {
    sayHello: function (lang) {
        return helloInLang[lang];
    }
};

// file hello.js
import { greeting } from "./lib/greeting";
const phrase = greeting.sayHello("en");
document.write(phrase);
```



As we can see the standard introduces the brand new keywords for importing of modules using the keyword `import` and exporting of the code using the keyword `export`.

Due to the fact that we are dealing with [new keywords in the language](https://hacks.mozilla.org/2015/08/es6-in-depth-modules/), and also because the Module Loader API specification, which is responsible for supporting loading modules in various environments, is not yet ready, we can't just pick up and start using the new native module system.

In spite of this limitations a lot of projects have started to use the new format of the modules. To start use the new standard in a world where ES5 is most common, you can use the [Babel](https://github.com/babel/babel) transpilation, which is a fairly common practice.

## Conclusion

There are other approaches for the modularity in JS. Some of them can intertwine with each other [creating bizarre forms](http://requirejs.org/docs/api.html#cjsmodule), others were created specifically for using in a [particular project](https://github.com/Artificial-Engineering/lycheejs/blob/development/projects/pong/source/Main.js#L2-L6), and some were created as a [transitive format](https://github.com/ModuleLoader/es-module-loader/blob/v0.17.0/docs/system-register.md). Describing them all is a fairly non-trivial task, therefore the article has discussed only the most popular approaches and formats. Nevertheless, I think that this article has helped you to learn something new, to systematise the knowledge about modularity in JavaScript and to learn a little more about those people, who stood behind all these technologies.

# 内容概要

**直接定义依赖 (1999)**: 由于当时 js 文件非常简单，模块化方式非常简单粗暴 —— 通过全局方法定义、引用模块。这种定义方式与现在的 commonjs 非常神似，区别是 commonjs 以文件作为模块，而这种方法可以在任何文件中定义模块，模块不与文件关联。

**闭包模块化模式 (2003)**: 用闭包方式解决了变量污染问题，闭包内返回模块对象，只需对外暴露一个全局变量。

**模版依赖定义 (2006)**: 这时候开始流行后端模版语法，通过后端语法聚合 js 文件，从而实现依赖加载，说实话，现在 go 语言等模版语法也很流行这种方式，写后端代码的时候不觉得，回头看看，还是挂在可维护性上。

**注释依赖定义 (2006)**: 几乎和模版依赖定义同时出现，与 1999 年方案不同的，不仅仅是模块定义方式，而是终于以文件为单位定义模块了，通过 [lazyjs](https://github.com/bevacqua/lazyjs) 加载文件，同时读取文件注释，继续递归加载剩下的文件。

**外部依赖定义 (2007)**: 这种定义方式在 cocos2d-js 开发中普遍使用，其核心思想是将依赖抽出单独文件定义，这种方式不利于项目管理，毕竟依赖抽到代码之外，我是不是得两头找呢？所以才有通过 webpack 打包为一个文件的方式暴力替换为 commonjs 的方式出现。

**Sandbox 模式 (2009)**: 这种模块化方式很简单，暴力，将所有模块塞到一个 `sandbox` 变量中，硬伤是无法解决命名冲突问题，毕竟都塞到一个 `sandbox` 对象里，而 `Sandbox` 对象也需要定义在全局，存在被覆盖的风险。模块化需要保证全局变量尽量干净，目前为止的模块化方案都没有很好的做到这一点。

**依赖注入 (2009)**: 就是大家熟知的 angular1.0，依赖注入的思想现在已广泛运用在 react、vue 等流行框架中。但依赖注入和解决模块化问题还差得远。

**CommonJS (2009)**: 真正解决模块化问题，从 node 端逐渐发力到前端，前端需要使用构建工具模拟。

**Amd (2009)**: 都是同一时期的产物，这个方案主要解决前端动态加载依赖，相比 commonJs，体积更小，按需加载。

**Umd (2011)**: 兼容了 CommonJS 与 Amd，其核心思想是，如果在 commonjs 环境（存在 `module.exports`，不存在 `define`），将函数执行结果交给 `module.exports` 实现 Commonjs，否则用 Amd 环境的 `define`，实现 Amd。

**Labeled Modules (2012)**: 和 Commonjs 很像了，没什么硬伤，但生不逢时，碰上 Commonjs 与 Amd，那只有被人遗忘的份了。

**YModules (2013)**: 既然都出了 Commonjs Amd，文章还列出了此方案，一定有其独到之处。其核心思想在于使用 `provide` 取代 `return`，可以控制模块结束时机，处理异步结果；拿到第二个参数 `module`，修改其他模块的定义（虽然很有拓展性，但用在项目里是个搅屎棍）。

**ES2015 Modules (2015)**: 就是我们现在的模块化方案，还没有被浏览器实现，大部分项目已通过 `babel` 或 `typescript` 提前体验。

# 精读

## 从语言层面到文件层面的模块化

> 从 1999 年开始，模块化探索都是基于语言层面的优化，真正的革命从 2009 年 CommonJS 的引入开始，前端开始大量使用预编译。

这篇文章所提供的模块化历史的方案都是逻辑模块化，**从 CommonJS 方案开始前端把服务端的解决方案搬过来之后，算是看到标准物理与逻辑统一的模块化**。但之后前端工程不得不引入模块化构建这一步。正是这一步给前端开发无疑带来了诸多的不便，尤其是现在我们开发过程中经常为了优化这个工具带了很多额外的成本。

从 CommonJS 之前其实都只是封装，并没有一套模块化规范，这个就有些像类与包的概念。我在 10 年左右用的最多的还是 YUI2，YUI2 是用 namespace 来做模块化的，但有很多问题没有解决，比如多版本共存，因此后来 YUI3 出来了。

```js
YUI().use('node', 'event', function (Y) {
    // The Node and Event modules are loaded and ready to use.
    // Your code goes here!
});
```

YUI3 的 sandbox 像极了差不多同时出现的 AMD 规范，但早期 yahoo 在前端圈的影响力还是很大的，而 requirejs 到 2011 年才诞生，因此圈子不是用着 YUI 要不就自己封装一套 sandbox，内部使用 jQuery。

为什么模块化方案这么晚才成型，可能早期应用的复杂度都在后端，前端都是非常简单逻辑。后来 Ajax 火了之后，web app 概念的开始流行，前端的复杂度也呈指数级上涨，到今天几乎和后端接近一个量级。**工程发展到一定阶段，要出现的必然会出现。** 

## 前端三剑客的模块化展望

> 从 js 模块化发展史，我们还看到了 css html 模块化方面的严重落后，如今依赖编译工具的模块化增强在未来会被标准所替代。

原生支持的模块化，**解决 html 与 css 模块化问题正是以后的方向。**

再回到 JS 模块化这个主题，开头也说到是为了构建 scope，实则提供了业务规范标准的输入输出的方式。但文章中的 JS 的模块化还不等于前端工程的模块化，Web 界面是由 HTML、CSS 和 JS 三种语言实现，不论是 CommonJS 还是 AMD 包括之后的方案都无法解决 CSS 与 HTML 模块化的问题。

对于 CSS 本身它就是 global scope，因此开发样式可以说是喜忧参半。近几年也涌现把 HTML、CSS 和 JS 合并作模块化的方案，其中 react/css-modules 和 vue 都为人熟知。当然，这一点还是非常依赖于 webpack/rollup 等构建工具，让我们意识到在 browser 端还有很多本质的问题需要推进。

对于 css 模块化，目前不依赖预编译的方式是 `styled-component`，通过 js 动态创建 class。而目前 css 也引入了[与 js 通信的机制 与 原生变量支持](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_variables)。未来 css 模块化也很可能是运行时的，所以目前比较看好 `styled-component` 的方向。

对于 html 模块化，小尤最近爆出与 chrome 小组调研 html Modules，如果 html 得到了浏览器，编辑器的模块化支持，未来可能会取代 jsx 成为最强大的模块化、模板语言。

对于 js 模块化，最近出现的 `<script type="module">` 方式，虽然还没有得到浏览器原生支持，但也是我比较看好的未来趋势，这样就连 webpack 的拆包都不需要了，直接把源代码传到服务器，配合 http2.0 完美抛开预编译的枷锁。

上述三种方案都不依赖预编译，分别实现了 html、css、js 模块化，相信这就是未来。

## 模块化标准推进速度仍然缓慢

> 2015 年提出的标准，在 17 年依然没有得到实现，即便在 nodejs 端。

这几年 TC39 对语言终于重视起来了，慢慢有动作了，但针对模块标准制定的速度，与落实都非常缓慢，与 javascript 越来越流行的趋势逐渐脱节。nodejs 至今也没有实现 ES2015 模块化规范，所有 jser 都处在构建工具的阴影下。

## Http 2.0 对 js 模块化的推动

> js 模块化定义的再美好，浏览器端的支持粒度永远是瓶颈，http 2.0 正是考虑到了这个因素，大力支持了 ES 2015 模块化规范。

幸运的是，模块化构建将来可能不再需要。随着 HTTP/2 流行起来，请求和响应可以并行，一次连接允许多个请求，对于前端来说宣告不再需要在开发和上线时再做编译这个动作。

几年前，模块化几乎是每个流行库必造的轮子（YUI、Dojo、Angular），大牛们自己爽的同时其实造成了社区的分裂，很难积累。有了 ES2015 Modules 之后，JS 开发者终于可以像 Java 开始者十年前一样使用一致的方式愉快的互相引用模块。

不过 ES2015 Modules 也只是解决了开发的问题，由于浏览器的特殊性，还是要经过繁琐打包的过程，等 Import，Export 和 HTTP 2.0 被主流浏览器支持，那时候才是彻底的模块化。

## Http 2.0 后就不需要构建工具了吗？

> 看到大家基本都提到了 HTTP/2，对这项技术解决前端模块化及资源打包等工程问题抱有非常大的期待。很多人也认为 HTTP/2 普及后，基本就没有 Webpack 什么事情了。

不过 Webpack 作者 @sokra 在他的文章 [webpack & HTTP/2](https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.zdo4juvgo) 里提到了一个新的 Webpack 插件 `AggressiveSplittingPlugin`。简单的说，这款插件就是为了充分利用 HTTP/2 的文件缓存能力，将你的业务代码自动拆分成若干个数十 KB 的小文件。后续若其中任意一个文件发生变化，可以保证其他的小 chunk 不需要重新下载。

可见，**即使不断的有新技术出现，也依然需要配套的工具来将前端工程问题解决方案推向极致。**

## 模块化是大型项目的银弹吗？

> 只要遵循了最新模块化规范，就可以使项目具有最好的可维护性吗？ Js 模块化的目的是支持前端日益上升的复杂度，但绝不是唯一的解决方案。

分析下 JavaScript 为什么没有模块化，为什么又需要模块化：这个 95 年被设计出来的时候，语言的开发者根本没有想到它会如此的大放异彩，也没有将它设计成一种模块化语言。按照文中的说法，99 年也就是 4 年后开始出现了模块化的需求。如果只有几行代码用模块化是扯，初始的 web 开发业务逻辑都写在 server 端，js 的作用小之又小。而现在 spa 都出现了，几乎所有的渲染逻辑都在前端，如果还是没有模块化的组织，开发过程会越来越难，维护也是更痛苦。

文中已经详细说明了模块化的发展和优劣，这里不准备做过多的讨论。我想说的是，**在模块化之后还有一个模块间耦合的问题，如果模块间耦合度大也会降低代码的可重用性或者说复用性**。所以也出现了降低耦合的观察者模式或者发布/订阅模式。这对于提升代码重用，复用性和避免单点故障等都很重要。说到这里，还想顺便提一下最近流行起来的响应式编程（RxJS），响应式编程中有一个很核心的概念就是 observable，也就是 Rx 中的流（stream）。它可以被 subscribe，其实也就是观察者设计模式。

## 补充阅读

- [JavaScript 模块化七日谈](https://huangxuan.me/2015/07/09/js-module-7day/)
- [JavaScript 模块化编程简史（2009-2016）](https://yuguo.us/weblog/javascript-module-development-history/)

# 总结

未来前端复杂度不断增加已成定论，随着后端成熟，自然会将焦点转移到前端领域，而且服务化、用户体验越来越重要，前端体验早不是当初能看就行，任何网页的异常、视觉的差异，或文案的模糊，都会导致用户流失，支付中断。前端对公司营收的影响，渐渐与后端服务宕机同等严重，所以前端会越来越重，异常监控，性能检测，工具链，可视化等等都是这几年大家逐渐重视起来的。

我们早已不能将 javascript 早期玩具性质的模块化方案用于现代越来越重要的系统中，前端界必然出现同等重量级的模块化管理方案，感谢 TC39 制定的 ES2015 模块化规范，我们已经离不开它，哪怕所有人必须使用 babel。

话说回来，标准推进的太慢，我们还是把编译工具当作常态，抱着哪怕支持了 ES2015 所有特性，babel 依然还有用的心态，将预编译进行到底。一句话，模块化仍在路上。js 模块化的矛头已经对准了 css 与 html，这两位元老也该向前卫的 js 学习学习了。

未来 css、html 的模块化会自立门户，还是赋予 js 更强的能力，让两者的模块化依附于 js 的能力呢？目前 html 有自立门户的苗头（htmlModules），而 css 迟迟没有改变，社区出现的 `styled-component` 已经用 js 将 css 模块化得很好了，最新 css 规范也支持了与 js 的变量通信，难道希望依附于 js 吗？这里希望得到大家更广泛的讨论。

我也认同，毕竟压缩、混淆、md5、或者利用 [nonce](https://www.thepolyglotdeveloper.com/2015/03/create-a-random-nonce-string-using-javascript/) 属性对 script 标签加密，都离不开本地构建工具。

据说 http2 的优化中，有个最佳文件大小与数量的比例，那么还是脱离不了构建工具，前端未来会越来越复杂，同时也越来越美好。

至此，对于 javascript 模块化讨论已接近尾声，对其优缺点也基本达成了一致。前端复杂度不断提高，促使着模块化的改进，代理（浏览器、node） 的支持程度，与前端特殊性（流量、缓存）可能前端永远也离不开构建工具，新的标准会让这些工作做的更好，同时取代、增强部分特征，前端的未来是更加美好的，复杂度也更高。