## 11. what is Composition? create a pipe()

现在需要你自己写一个`pipe()` 方法。

假设有一些简单的四则运算方法：

```js
const times = (y) =>  (x) => x * y
const plus = (y) => (x) => x + y
const subtract = (y) => (x) => x - y
const divide = (y) => (x) => x / y
```

`pipe()` 可以用来生成新的计算方式

```js
pipe([
  times(2),
  times(3)
])  
// x * 2 * 3

pipe([
  times(2),
  plus(3),
  times(4)
]) 
// (x * 2 + 3) * 4

pipe([
  times(2),
  subtract(3),
  divide(4)
]) 
// (x * 2 - 3) / 4
```

**注意**

1. 为了简单，可以假设传给`pipe()`的方法都只有一个参数

```js
function pipe(funcs) {
	return (x) => {
		let result = x
		if(funcs.length > 0){
			funcs.forEach(f => result = f(result))
		}
		return result;
	}
}
```

## 12. arguments

What does the code snippet to the right output by `console.log`?

```js
function log(a,b,c,d) {
  console.log(a,b,c,d)
  arguments[0] = 'bfe'
  arguments[3] = 'dev'
  console.log(a,b,c,d)
}

log(1,2,3)
```

[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments) 是一个包含了传递给函数的参数的类数组对象，**类数组**意味着 `arguments` 有长度属性，并且属性的索引是从零开始的，但是它没有 `Array` 的内置方法，不过可以调用 `Array` 原型上的方法，此外如果调用的参数多于正式声明接受的参数，这也是一个很好的示例：

```js
function myConcat(separator) {
  var args = Array.prototype.slice.call(arguments, 1);
  return args.join(separator);
}


// returns "red, orange, blue"
myConcat(", ", "red", "orange", "blue");
// returns "elephant; giraffe; lion; cheetah"
myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
```

 `arguments` 在函数中，可以进行赋值更新，但是通过索引进行赋值时，**如果是没有传参的形参位置，是不能更新赋值的**，所以上面的输出应该是：

```text
1,2,3,undefined
"bfe",2,3,undefined
```

## 13. Operator precedence

What does the code snippet to the right output by `console.log`?

```js
console.log(0 == 1 == 2) // false == 2 👉🏻 0 == 2 👉🏻 false
console.log(2 == 1 == 0) // false == 0 👉🏻 0 == 0 👉🏻 true
console.log(0 < 1 < 2)   // true < 2 👉🏻 1 < 2 👉🏻 true
console.log(1 < 2 < 3)   // true < 3 👉🏻 1 < 3 👉🏻 true
console.log(2 > 1 > 0)   // true > 0 👉🏻 1 > 0 👉🏻 true
console.log(3 > 2 > 1)   // true > 1 👉🏻 1 > 1 👉🏻 false
```

这里的一个重要细节是，如果一个操作数是布尔值，另一个是数字，则会先将布尔值转换为数字类型。 `true` 被转换为数字 1， `false` 被转换为数字 0。

这是通过 ECMAScript 的规范中定义的抽象相等比较算法（Abstract Equality Comparison）实现的，其中主要是对 boolean 做了 [ToNumber](https://tc39.es/ecma262/#sec-tonumber) 操作：

> **ToNumber ( argument )**
>   4. If argument is either null or false, return +0𝔽.
>   5. If argument is true, return 1𝔽.

## 14. Addition vs Unary Plus

What does the code snippet to the right output by `console.log`?

There is a difference between [Addition Operator(+)](https://tc39.es/ecma262/#sec-addition-operator-plus "null") and [Unary plus operator(+)](https://tc39.es/ecma262/#sec-unary-plus-operator "null"), even though they use the same '+'.

```js
console.log(1 + 2) // 3
console.log(1 + + 2) // 1 + (+2) = 1 + 2 = 3
console.log(1 + + + 2) // 1 + (+(+2)) = 1 + 2 = 3
console.log(1 + '2') // "1" + "2" = "12" 
console.log(1 + + '2') // 1 + (+2) = 1 + 2 = 3
console.log('1' + 2) // "1" + "2" = "12"
console.log('1' + + 2) // "1" + (+2) = "1" + 2 = "1" + "2" = "12"
console.log(1 + true) // 1 + 1 = 2
console.log(1 + + true) // 1 + (+true) = 1 + 1 = 2
console.log('1' + true) // "1" + "true" = "1true"
console.log('1' + + true) // "1" + (+true) = "1" + 1 = "1" + "1" = "11"
console.log(1 + null) // 1 + 0 = 1
console.log(1 + + null) // 1 + (+null) = 1 + 0 = 1
console.log('1' + null) // "1" + "null" = "1null"
console.log('1' + + null) // "1" + (+null) = "1" + 0 = "1" + "0" = "10"
console.log(1 + undefined) // 1 + NaN = NaN
console.log(1 + + undefined) // 1 + (+undefined) = 1 + NaN = NaN
console.log('1' + undefined) // "1" + "undefined" = "1undefined"
console.log('1' + + undefined) // "1" + (+undefined) = "1" + NaN = "1" + "NaN" = "1NaN"
console.log('1' + + + undefined) // "1" +(+(+undefined)) = "1" + NaN = "1" + "NaN" = "1NaN"
```

The unary plus operator (+) 将其后的操作数转为数字类型：

```js
+1 // 1
+"1" // 1
+true // 1
+null // 0
+undefined // NaN
+NaN // NaN
```

Addition operator `+` 前的操作数如果为数字，则会将其后的操作数转为数字进行相加；否则将执行字符串拼接，也就将其后的操作数转为字符串。
