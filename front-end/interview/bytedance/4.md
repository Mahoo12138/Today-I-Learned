## 简述 TCP 和 UDP 的区别和使用场景

TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Datagram Protocol，用户数据报协议）是两种常见的传输层协议。它们的主要区别在于是否保证数据传输的可靠性、顺序和完整性。

### 1. 连接方式

**TCP**：

- **面向连接**：在传输数据之前，TCP 需要通过三次握手建立连接。连接建立后，双方可以开始数据交换，直到连接通过四次挥手断开。
- **连接建立与断开需要时间**：由于需要建立和断开连接，TCP 的建立和断开相对较慢。

**UDP**：

- **无连接**：UDP 是无连接的协议，发送数据之前不需要与接收方建立连接。每个数据包都是独立的，发送方不关心接收方是否准备好接收数据。
- **无连接开销**：UDP 不需要建立连接，传输数据时开销较小，数据传输速度更快。

### 2. **数据传输方式**

**TCP**：

- **面向字节流**：TCP 是面向字节流的协议，它将数据视为一个字节流传输，数据在网络上传输时没有边界，接收方按顺序读取字节流。
- **分段和重组**：如果发送的数据量过大，TCP 会将数据分成多个段进行传输，接收方再将数据段重组。

**UDP**：

- **面向数据报**：UDP 是面向数据报的协议，每个数据报都是一个独立的单位，UDP 会尽力将数据报传输给接收方，而不会进行拆分和重组。

### 3. 可靠性

**TCP**：

- **可靠性保证**：TCP 是面向连接的协议，提供可靠的数据传输。它通过三次握手建立连接，并通过四次挥手断开连接。它使用确认应答（ACK）、重传机制、序列号等方式确保数据按顺序、无差错地到达接收端。
- **数据顺序**：TCP 保证数据按发送顺序到达接收端，接收端可以确保数据是有序的。
- **流量控制和拥塞控制**：TCP 提供流量控制，确保发送方不会超过接收方的处理能力，并且会动态调整发送速率来适应网络的拥塞情况。

**UDP**：

- **不可靠**：UDP 是无连接的协议，不提供数据传输的可靠性保证。发送的数据报可能会丢失、重复或乱序，接收方没有机制来确保数据是否正确接收到。
- **无顺序保证**：UDP 不保证数据按发送顺序到达，接收方收到的数据包的顺序可能与发送顺序不同。
- **无流量控制和拥塞控制**：UDP 不进行流量控制和拥塞控制，发送方可以以任何速率发送数据，不管接收方是否准备好接收。

### 4. 传输速度

**TCP**：

- **速度较慢**：由于需要保证数据的可靠性、顺序和流量控制等机制，TCP 相比 UDP 会消耗更多的时间和资源，导致传输速度较慢。
- **重传机制**：如果数据丢失或出错，TCP 会进行重传，这增加了传输的延迟。

**UDP**：

- **速度较快**：由于没有连接建立过程、没有重传机制和流量控制等，UDP 传输的速度相对较快，适合需要高吞吐量和低延迟的场景。

### 5. 错误检查

- TCP：**有错误检查**——TCP 使用校验和、序列号、确认机制等方法来确保数据的完整性，并且会在检测到错误时重新传输数据。
- UDP：**有基本的错误检查**——UDP 使用校验和进行基本的错误检查，但不会进行重传。即使数据包丢失或损坏，UDP 也不会尝试恢复。

### 6. 使用场景

**TCP** 适用场景：需要保证数据完整性、顺序和可靠性的场景；实时性要求不高，可靠性优先的应用。

- Web 浏览（HTTP/HTTPS）
- 文件传输（FTP）
- 电子邮件（SMTP）
- 数据库连接（MySQL、PostgreSQL）
- 虚拟专用网络（VPN）等需要可靠连接的应用。

**UDP**适用场景：需要快速传输且能够容忍数据丢失的场景；实时性和低延迟要求高，容忍一定丢包的应用；

- 视频会议、实时视频流（例如：YouTube、Netflix 等）
- VoIP 通话（例如：Skype、Zoom 等）
- 在线游戏（如多人游戏，尤其是需要实时反馈的场景）
- DNS 查询（域名解析）
- 直播流媒体、音频传输等。

## QUIC 如何基于 UDP 实现可靠性

**QUIC**（Quick UDP Internet Connections）是一个由 Google 提出的基于 **UDP** 协议的传输层协议，旨在替代传统的 TCP 协议，提供更低的延迟和更高的效率。虽然 QUIC 是基于 **UDP** 的，但它通过自身的机制保证了 **可靠性、顺序传输** 和 **丢包恢复** 等特性，这些通常是 TCP 提供的功能。

QUIC 通过在 UDP 的基础上实现一些增强功能，弥补了 UDP 本身缺乏的可靠性和顺序保证。以下是 QUIC 实现可靠性的几种关键机制：

### **1. 数据包重传**

- **TCP 中的重传机制**：在 TCP 中，传输层协议会自动对丢失的数据包进行重传。

- **QUIC 中的重传机制**：QUIC 在应用层模拟了类似 TCP 的重传机制。QUIC 会通过 **确认应答**（ACK）来确保数据包成功到达接收方。如果接收方没有收到某个数据包，QUIC 会自动请求重传，确保丢失的数据包能够恢复。

  QUIC 会维护每个数据流的状态，并跟踪哪些数据包已经确认接收，哪些数据包丢失了。每当数据包丢失时，QUIC 会发送一个 **重传请求**，告知发送方哪些数据包没有到达，发送方会根据请求进行重传。

### **2. 流量控制**

- **TCP 的流量控制**：TCP 使用 **窗口滑动机制** 来控制数据流，确保发送方的发送速率不会超过接收方的处理能力。
- **QUIC 的流量控制**：QUIC 使用类似于 TCP 的流量控制机制，确保接收方不会被发送方发送的过多数据压垮。每个数据流都有一个独立的流量控制窗口，QUIC 会根据接收方的窗口大小来调整发送速率，避免丢包和拥塞。

### **3. 传输顺序保证**

- **TCP 的顺序保证**：TCP 会保证数据包按顺序到达接收方，如果数据包乱序，TCP 会重新排列顺序。
- **QUIC 的顺序保证**：虽然 QUIC 基于 UDP，而 UDP 本身不保证数据顺序，但 QUIC 会为每个数据流维护一个 **序列号**，确保数据流中的数据包按顺序传输。如果某些数据包乱序到达，QUIC 会利用序列号重新排序，保证应用层收到的数据是按正确顺序排列的。

### **4. 连接恢复与拥塞控制**

- **TCP 的拥塞控制**：TCP 使用拥塞控制算法（如 **慢启动**、**拥塞避免**、**快速重传** 等）来避免网络出现拥塞，确保网络资源的有效利用。
- **QUIC 的拥塞控制**：QUIC 也实现了类似于 TCP 的 **拥塞控制机制**，比如 **慢启动** 和 **拥塞避免**，它会根据网络的实际状况动态调整发送速率。QUIC 通过监控丢包率和往返时间（RTT）来计算合适的窗口大小和发送速率，从而有效避免网络拥塞。

### **5. 多路复用**

- **TCP 的多路复用**：在 TCP 中，一个连接只能处理一个数据流，多个请求需要建立多个连接，增加了延迟和资源消耗。
- **QUIC 的多路复用**：QUIC 支持在同一个连接上复用多个数据流（类似 HTTP/2 的多路复用）。每个数据流都有自己的流标识符和状态，允许多个数据流并发传输，避免了 TCP 中由于头部阻塞（Head-of-Line Blocking）问题。

### **6. 0-RTT 连接恢复**

- **TCP 的连接恢复**：TCP 协议每次建立连接时都需要经过三次握手，导致较长的连接建立延迟。
- **QUIC 的连接恢复**：QUIC 支持 **0-RTT** 连接恢复，即在先前连接建立过的基础上，客户端可以立即发送加密数据包，而无需等待服务端的响应。这样，QUIC 可以在 **网络切换** 或 **会话恢复** 时减少连接建立的延迟。

### **7. 加密机制**

- **TCP 的加密**：TCP 本身不提供加密机制，但可以与 TLS 等协议结合提供加密传输。
- **QUIC 的加密**：QUIC 自带加密机制，所有的数据传输都默认启用 **TLS 1.3** 加密。由于加密和解密都在传输层进行，因此 QUIC 在保证数据安全性的同时，能够提高性能，减少加密相关的延迟。

### **总结：QUIC 如何保证可靠性**

- **重传机制**：QUIC 自行实现重传机制，确保丢失的数据包能够恢复。
- **流量控制**：QUIC 提供流量控制，防止发送方过度发送数据，确保接收方处理能力不会被超载。
- **顺序保证**：虽然 UDP 不保证数据顺序，但 QUIC 会利用序列号来保证数据按正确顺序传输。
- **拥塞控制**：QUIC 实现了与 TCP 类似的拥塞控制机制，防止网络拥塞。
- **多路复用**：QUIC 支持多个数据流的复用，减少了延迟并避免了头部阻塞。
- **加密机制**：QUIC 内置了 TLS 加密，提供了安全的传输机制，同时减少了加密相关的延迟。

## SSR 和 CSR 的 区别

SSR（Server-Side Rendering，服务器端渲染）和 CSR（Client-Side Rendering，客户端渲染）是两种不同的 Web 渲染方式，它们分别在服务器和客户端处理页面渲染的过程。它们的主要区别在于渲染逻辑的执行位置（服务器还是客户端），以及它们对页面加载速度、SEO、用户体验等方面的影响。

### 1. **渲染过程**

- **SSR（服务器端渲染）**：
  - 页面在服务器端渲染并生成完整的 HTML 页面，服务器将渲染后的 HTML 发送到浏览器，浏览器直接显示内容。
  - 服务器渲染的内容是一个完整的页面，客户端浏览器只负责显示和交互。
  - 例如，使用 **Vue SSR** 或 **Next.js**（React）等框架。
- **CSR（客户端渲染）**：
  - 初次请求时，浏览器加载一个空的 HTML 页面和 JavaScript 代码，JavaScript 会在浏览器端执行，利用 JavaScript 来渲染页面内容（通常通过框架如 React、Vue 等）。
  - 浏览器从服务器加载的是一个静态的 HTML 模板，之后 JavaScript 会接管页面渲染。
  - 初始渲染时，页面通常是一个空白页，等到 JavaScript 加载和渲染完成后，页面才显示内容。

### 2. **首屏渲染时间（Page Load Time）**

- **SSR**：由于服务器已经渲染了完整的 HTML 页面，浏览器可以在接收到页面后直接显示内容，因此首屏加载时间通常更短，用户能更快看到页面。
- **CSR**：浏览器需要加载 JavaScript 文件并在客户端进行渲染，首次加载时间相对较长，用户会先看到一个空白页，直到 JavaScript 渲染完成后才显示内容。

### 3. **SEO（搜索引擎优化）**

- **SSR**：由于服务器返回的是完整的 HTML 页面，搜索引擎爬虫可以直接抓取页面的内容，因此 SSR 对 SEO 非常友好，有利于搜索引擎索引和排名。
- **CSR**：由于搜索引擎爬虫通常只抓取初始的 HTML 代码，而 JavaScript 渲染的内容需要客户端执行，很多搜索引擎（如 Google）已支持客户端渲染，但仍有一定的兼容性问题，SEO 支持相对较差。

### 4. **用户体验**

- **SSR**：SSR 由于页面内容在服务器端渲染完成后直接返回，首屏渲染速度快，用户能够更快看到内容，因此用户体验更好，特别是在慢网络环境下。
- **CSR**：CSR 初次加载时，用户需要等待 JavaScript 加载和渲染，可能会体验到空白页或延迟加载的现象，虽然后续的页面切换会很快，但首次渲染的时间较长。

### 5. **交互性（动态更新）**

- **SSR**：由于是服务器渲染的 HTML 页面，用户与页面的交互需要通过额外的请求与服务器进行数据交换。每次用户与页面交互（如点击按钮或表单提交）时，通常需要重新加载和渲染页面。
- **CSR**：CSR 的页面一旦加载完毕，所有交互都是通过 JavaScript 在客户端处理的，不需要每次请求都刷新整个页面，因此页面可以更快地响应用户交互，提供更流畅的用户体验。

### 6. **服务器负载**

- **SSR**：每次用户请求页面时，服务器需要处理渲染的逻辑，生成 HTML，负载较大。尤其是在访问量很大的情况下，服务器性能要求较高。
- **CSR**：页面的渲染和大部分逻辑处理都在客户端完成，服务器的负担较轻，服务器只需要提供静态的 HTML 和数据接口。

### 7. **开发复杂度**

- **SSR**：实现 SSR 比 CSR 要复杂一些，因为需要处理服务器端渲染、状态同步、路由等问题，开发者需要对服务器端技术有一定了解。
- **CSR**：实现相对简单，尤其是使用现代前端框架（如 React、Vue、Angular）时，CSR 的开发模式和工具链成熟，开发速度较快。

### 8. **数据预取**

- **SSR**：SSR 可以在服务器渲染页面之前获取数据，并直接将数据渲染到 HTML 页面中，用户看到的页面已经是渲染好的内容。
- **CSR**：CSR 需要通过异步请求（如 AJAX 或 Fetch API）来获取数据，在渲染时填充数据。第一次加载时，通常需要等待数据加载完毕，才能进行渲染。

### 总结

- **SSR**：
  - 优点：更快的首屏渲染、良好的 SEO 支持、更适合内容驱动的应用。
  - 缺点：服务器负担重、开发复杂度高、动态交互不如 CSR 流畅。
- **CSR**：
  - 优点：减少服务器负担、页面交互更流畅、开发更加简便。
  - 缺点：首屏渲染较慢、SEO 支持较弱（不过现在的搜索引擎已逐渐支持 JavaScript 渲染）。

### 使用场景

- **SSR** 适用于 SEO 要求较高、页面内容需要快速显示的应用，如博客、新闻网站、营销页面等。
- **CSR** 适用于交互性要求高、页面更新较为频繁的应用，如单页应用（SPA）、社交网络、即时通讯等。

## windows.onload

`window.onload` 是一个在网页完全加载并且所有元素（包括图片、脚本、样式表等）都加载完成后才会触发的事件。

+ 执行初始化操作；
+ 确保 DOM 元素可操作；
+ 延迟执行某些任务；

**注意事项**

+ `window.onload` **只能绑定一个函数**，需要绑定多个事件处理函数，可以使用 `addEventListener` 的 `load` 事件（现代浏览器支持）；
+ `window.onload` 会在 **页面的所有资源（包括图片、音视频、iframe 等）完全加载完成后才触发**。这可能导致一些延迟，尤其是在有大量资源的页面中，`window.onload` 触发的时间较长。
+ **异步加载资源可能会影响页面加载时机**： 如果你使用 `window.onload` 来执行与页面加载相关的 JavaScript 代码（例如加载数据、图片或其他资源），需要小心异步加载的资源可能会导致 `window.onload` 触发的时机有所延迟。
+ **性能问题**： 如果 `window.onload` 内部绑定的任务过于复杂或包含大量代码，可能会导致页面加载和渲染延迟，影响用户体验。确保在 `window.onload` 中的操作不会阻塞页面的显示。

