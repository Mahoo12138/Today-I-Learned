## 复杂性的定义

系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。
$$
C = \sum\limits_p {{c_p}{t_p}} 
$$
## 复杂性的症状

+ **变更放大**：看似简单的变更需要在许多不同地方进行代码修改；
+ **认知负荷**：需要多少知识才能完成一项任务，认知负荷加大需要花更多时间，也增加了错误风险；
+ **未知的未知**：必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务；

在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。

良好设计的最重要目标之一就是使系统显而易见。

一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。

## 复杂性的原因

复杂性是由两件事引起的：**依赖性**和**模糊性**。

### 依赖性

当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。

依赖关系是软件的基本组成部分，不能完全消除。实际上，我们在软件设计过程中有意引入了依赖性。

但是，软件设计的目标之一是减少依赖关系的数量，并使**依赖关系保持尽可能简单和明显**。

### 模糊性

当重要的信息不明显时，就会发生模糊。

在许多情况下，由于文档不足而导致模糊不清。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。

减少模糊性的最佳方法是简化系统设计。

依赖性导致变更放大和高认知负荷。模糊会产生未知的未知数，还会增加认知负担。

## 复杂度是递增的

单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。

**复杂性的出现，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成**。

复杂性的增量性质使其难以控制。

可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。

## 结论

**复杂性来自于依赖性和模糊性的积累**。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。

此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，**复杂性使得修改现有代码库变得困难且冒险**。