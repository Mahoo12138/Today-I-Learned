**头部阻塞（Head-of-Line blocking）**是指在一个队列中，由于队首的请求被阻塞，导致后续的请求即使已经准备好，也无法得到处理的现象。

### HTTP/1.1 中的 HOL Blocking

在 HTTP/1.1 中，HOL blocking 可能会发生在以下两个层面：

1. **连接层面**：
    
    - HTTP/1.1 默认使用持久连接（persistent connection），允许在同一个 TCP 连接上发送多个请求，而无需为每个请求建立新的连接；
    - 虽然 HTTP/1.1 引入了**管线化（pipelining）技术**，允许客户端在不等待响应的情况下发送多个请求，但服务器必须按照接收请求的顺序依次发送响应；
    - 如果第一个请求的处理时间较长，或者由于网络问题导致延迟，那么后续的所有请求都会被阻塞，即使它们已经准备好被处理；
    - 由于管线化容易出错，并且在代理服务器中实现复杂，因此现代浏览器默认禁用该特性；
2. **TCP 层面**：
    
    - HTTP 协议构建于 TCP 协议之上。TCP 协议保证数据包按顺序传输，如果一个数据包丢失，后续的数据包必须等待丢失的数据包重传成功后才能被处理。
    - 即使 HTTP/1.1 使用多个 TCP 连接，每个连接仍然可能受到 TCP 层面 HOL blocking 的影响。

### HTTP/2 如何缓解 HOL Blocking

HTTP/2 通过以下机制来缓解 HOL blocking：

1. **多路复用（Multiplexing）**：
    
    - HTTP/2 引入了多路复用技术，允许在同一个 TCP 连接上并发地发送多个请求和响应。
    - 每个 HTTP 请求/响应都被分解为多个帧（frame），这些帧可以交错发送，接收端再将它们重新组装起来。
    - 这样，即使某个帧被延迟，也不会阻塞其他帧的传输。
2. **流（Stream）**：
    
    - HTTP/2 使用流的概念来标识不同的请求和响应。每个流都有一个唯一的 ID，客户端和服务器可以使用这些 ID 来区分不同的数据帧。
    - 通过流，HTTP/2 可以在一个 TCP 连接上并行处理多个请求和响应，从而避免了 HTTP/1.1 中的 HOL blocking。

### HTTP/2 仍然存在的 HOL Blocking

虽然 HTTP/2 解决了应用层面的 HOL blocking，但它仍然受到 TCP 层面 HOL blocking 的影响。由于 HTTP/2 仍然使用 TCP 作为传输协议，如果 TCP 连接中的一个数据包丢失，所有流都会受到影响，直到丢失的数据包被重传。

### HTTP/3 的解决方案

为了解决 TCP 层面 HOL blocking，HTTP/3 使用 QUIC 协议，QUIC 是一种基于 UDP 的传输协议。QUIC 协议具有以下特点：

- **独立的流**：QUIC 中的每个流都是独立的，一个流的数据包丢失不会影响其他流。
- **改进的拥塞控制**：QUIC 具有更好的拥塞控制机制，可以更快地恢复丢包，从而减少延迟。

通过使用 QUIC 协议，HTTP/3 彻底解决了 HOL blocking 问题。