## 1. implement curry()

```js
const join = (a, b, c) => {
   return `${a}_${b}_${c}`
}

const curriedJoin = curry(join)

curriedJoin(1, 2, 3) // '1_2_3'

curriedJoin(1)(2, 3) // '1_2_3'

curriedJoin(1, 2)(3) // '1_2_3'

function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length){
      return fn.apply(this, args)
    } else {
      return (...other) => {
        return curried.apply(this, args.concat(other))
      }
    }
  }
}
```

> + https://javascript.info/currying-partials
>
> + https://lodash.com/docs/4.17.15#curry

## 2. implement curry() with placeholder support

```js
const  join = (a, b, c) => {
   return `${a}_${b}_${c}`
}

const curriedJoin = curry(join)
const _ = curry.placeholder

curriedJoin(1, 2, 3) // '1_2_3'

curriedJoin(_, 2)(1, 3) // '1_2_3'

curriedJoin(_, _, _)(1)(_, 3)(2) // '1_2_3'
```

第二题，相比于第一题，多了一个 placeholder 占位符的处理，根据样例，后来的参数需要放置在之前的placeholder的地方。 大概想法和第一问是一样的，除了在**判断参数是否够用的时候，需要过滤掉 placeholder**：

```js
const expectedArgLength = func.length
const isArgsEnough = args.length >= expectedArgLength &&
  args.slice(0, expectedArgLength)
    .every(arg => arg !== curry.placeholder)
```

如果参数不够，和之前一样我们需要把参数和后来调用的参数合并在一起，再递归。 但是 这里不能简单的  `concat`，而需要寻找 placeholder 然后 merge：

```js
function curry(fn) {
  return function curried(...args) {
    const expectedArgLength = fn.length
    const isArgsEnough = args.length >= expectedArgLength &&
      args.slice(0, expectedArgLength)
        .every(arg => arg !== curry.placeholder)
    if (isArgsEnough) {
      return fn.apply(this, args)
    } else {
      return function (...newArgs) {
        const finalArgs = []
        let i = 0
        let j = 0
        while (i < args.length && j < newArgs.length) {
          if (args[i] === curry.placeholder) {
            finalArgs.push(newArgs[j])
            i += 1
            j += 1
          } else {
            finalArgs.push(args[i])
            i += 1
          }
        }

        while (i < args.length) {
          finalArgs.push(args[i])
          i += 1
        }

        while (j < newArgs.length) {
          finalArgs.push(newArgs[j])
          j += 1
        }
        return curried(...finalArgs)
      }
    }
  }
}
```

## 3. implement Array.prototype.flat()

```js
function flat(arr, depth = 1) {
  return depth ? 
    arr.reduce((acc, curr) => {
      return [...acc, ...(Array.isArray(curr) ? flat(curr, depth - 1) : [curr])]
    }, []) : arr;
}
```

## 4. implement basic throttle()

再次说明一下，`throttle(func, delay)`返回一个function，这个function无论多么频繁地调用，原始的 func 的调用也不会超过指定的频率。

比如，这是throttle之前的调用

```js
─ A ─ B ─ C ─ ─ D ─ ─ ─ ─ ─ ─ E ─ ─ F ─ G
```

按照3个单位进行throttle过后

```js
─ A ─ ─ ─ C ─ ─ ─D ─ ─ ─ ─ E ─ ─ ─ G 
```

注意到

- A 因为不在任何的冷却时间，所以立即被执行
- B 被跳过了，因为B和C都在A的冷却时间里。

**注意**

1. 请按照以上 spec 完成代码。以上逻辑和`lodash.throttle()`并不完全一致
2. 因为 `window.setTimeout` 和 `window.clearTimeout` 并不精确。所以在test你写的代码的时候，这两个方法会被替换为静态的实现。不过不用担心，interface 是一样的。

```js
function throttle(func, wait) {
    let waiting = false, lastArgs = null;
    return function(...args) {
        if(!waiting) {
            func.apply(this, args)
            waiting = true;
            let timeout = () => setTimeout(() => {
                waiting = false;
                if(lastArgs){
                    func.apply(this, lastArgs);
                    waiting = true;
                    lastArgs = null;
                    timeout();
                }
            }, wait);
            timeout();
        } else {
            lastArgs = args
        }
    }
}
```

`throttle` 是一个很考验闭包功底的练习，两个变量维护在闭包内：

+ `waiting`：记录当前是否处理等待状态；
+ `lastArgs`：记录上一次 throttle 调用的参数；

```mermaid
%%{init: {'zoom': 10}}%%
flowchart TB
    clause["waiting = false, lastArgs = null"]
    firstCall["func(0): called"]
    secondCall["func(1): wait"]
    alotof["many wait call..."]
    sixthCall["func(5): wait"]
    waitOver1["no func call: func(5) exec"]
    seventhCall["func(6): wait"]
    eighthCall["func(7): wait"]
    waitOver2["no func call: func(7) exec"]
    waiting["no func call, wait a moment..."]
    newCall["func(-1): called"]
    
    clause --> firstCall
    firstCall --> secondCall
    secondCall --> alotof
    alotof --> sixthCall
    sixthCall --> waitOver1
    waitOver1 --> seventhCall
    seventhCall --> eighthCall
    eighthCall --> waitOver2
    waitOver2 --> waiting
    waiting --> newCall
    
    subgraph "first call (called)"
      direction LR
      firstCall--> clause1["waiting = true, lastArgs = null, args = 0"]
    end
    
    subgraph "second call (timing)"
      direction RL
      secondCall--> clause2["waiting = true, lastArgs = 1, args = 0"]
    end
    
    subgraph "sixth call  (timing)"
      direction RL
      sixthCall--> clause6["waiting = true, lastArgs = 5, args = 0"]
    end
    
    subgraph "over call1  (time over)"
      direction RL
      waitOver1--> clause4["waiting = true, lastArgs = null, args = 0"]
    end

    subgraph "seventh call  (timing)"
      direction RL
      seventhCall--> clause7["waiting = true, lastArgs = 6, args = 0"]
    end
    subgraph "eighth call  (timing)"
      direction RL
      eighthCall--> clause8["waiting = true, lastArgs = 7, args = 0"]
    end
    subgraph "over call2  (time over)"
      direction RL
      waitOver2--> clause9["waiting = true, lastArgs = null, args = 0"]
    end
    

      waiting --> clause10["waiting = false, lastArgs = null, args = 0"]

    
    subgraph "new call  (called)"
      newCall --> clause11["waiting = false, lastArgs = null, args = -1"]
    end
```

我们从上图，一步步分析其中闭包变量变化，以及 throttled func （throttle 函数返回的函数）的执行：

+ 根据题目要求，第一次调用  throttled func 时需要执行一次，然后进入 waiting 状态；
+ 进入 waiting 状态时，会执行一个 setTimeout，等待时间则是传入的 wait，在这个时间间隔内， throttled func 都不会执行，而是将其参数保存到闭包中；
+ 之后的 func(1) ~ func(5) 都在 wait 间隔中调用了，每次调用都会更新 lastArgs，args 并没有随着 func 调用而更新；
+ 之后没有 func 调用，直到 wait 时间 timeout 了，获取到最新的 lastArgs = 5，调用原函数，并置空 lastArgs；
+ 紧接着 func(6)，func(7) 调用，仍在 wait 时间间隔内，类似操作，更新 lastArgs；
+ 之后没有 func 调用，使用 lastArgs = 7 执行原函数，置空 lastArgs；
+ 等到 wait 时间间隔外后，仍没有 func 调用，waiting = true，状态复原，将开启新一轮 throttled；
+ func(-1) 调用，首次直接执行，此时更新了 args；

> 这里的一个疑惑点，在于为什么要保留使用 lastArgs 保留上一次的 args ？
>
> 上述详细的分析可知，每次 timeout 闭包捕获的 args，其实都是 timeout 函数声明定义时观测到的作用域，也就是 timeout 的递归调用不结束，args 总是第一次执行时的值。
>
> 这不是主要原因，重点是，在 wait timeout 前的 throttled  时间内，如何忽略掉多次频繁的调用？
>
> 出于这个首要目的，我们首先要以 timeout 时间点为基准，之前的调用都不执行，只是记录调用的参数；
>
> timeout 后，获取最后一次传参执行函数，并以该参数为判断依据，决定是否需要继续 wait。
>
> 因为执行原函数后，仍会递归调用一次 timeout 函数，在内部判断是否存在 lastArgs，有值则继续 wait；
>
> 为空则清空 waiting 状态，等待新的 throttle 。
