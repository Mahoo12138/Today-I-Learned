---
title: 41. 缺失的第一个正数
tags:
  - leetcode/hash
  - leetcode/array
---
# [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive)

## 题目描述

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`

## 解法一：原地置换（桶排序思想）

### 核心思想

设数组长度为 n，将数组中的每个正整数 `x`，如果 `1 <= x <= n`，**放到索引 `x - 1` 的位置**上去。

> 理想状态：`nums[i] = i + 1`

遍历数组，将数字交换到它应在的位置（只要它满足 `1 ≤ nums[i] ≤ n`）

#### 思考策略

+ 如果要快速判断某个值是否出现过，**能不能把它“放在它该在的位置”上？**

+ 有没有某种“索引 ↔ 值”的天然映射关系？

只要发现这类“值 ↔ 索引”映射场景，就可以考虑这种 **原地哈希 / 桶排序思路**

#### 利用原数组当“哈希表”

可以「模拟哈希映射」，让数字 `x`（如果在 1~n 范围内）放到数组下标 `x - 1` 的位置。

举个简单的例子：

```
原数组：   [3, 4, -1, 1]

想要变成：  [1, -1, 3, 4]
索引：      0   1   2   3
值：       [1] [2] [3] [4]
```

你会发现，**如果数组中没有缺失任何数**，那么它的理想状态就是：

```
nums[i] === i + 1
```

也就是说，如果一个数字 `x` ∈ [1, n]，那它 **理应出现在 `x - 1` 的位置**。

如果我们能把每个数字放到它应该在的位置，那么：

- **数组中第一个不满足 `nums[i] === i + 1` 的位置**，就是我们要找的缺失正整数！

#### 最小正整数

因为要找的是**最小缺失的正整数**，那它肯定在 **`1 ~ n + 1` 的范围内**：

+ 最小正整数，所以理应从 1 开始查找，数组长度为 n，所以数组最多占据 `n + 1` 的位置；
+ 极端情况，数组顺序排列，如 `[1,2,3,4,5]`，那么最小缺失正整数则为 `n + 1 = 6`；

+ 另一种极端情况，如 `[7,8,9,11,12]`，即最小缺失正整数则为 `1 `；

为什么超过 n 的数字可以忽略，任何大于 `n` 的数都不可能占据一个“合法的索引”的查找位置（`x - 1` 必须在数组范围内），举个反例说明：

```js
nums = [7,8,9,11,12]  // 长度 n = 5
```

目标是找出最小缺失正整数，所有的数都大于 5，说明：

- 1 不在数组中
- 2 不在数组中
- 3 不在数组中
- 4 不在数组中
- 5 不在数组中

最小的缺失正整数显然是 `1`。

#### 总结

| 目的                                    | 原因                       |
| --------------------------------------- | -------------------------- |
| 构造一种 O(1) 查找机制                  | 把数值映射到对应的索引位   |
| 用数组本身模拟哈希表                    | 避免额外空间消耗           |
| 通过 `nums[i] !== i + 1` 快速定位缺失数 | 第一个不满足的位置就是答案 |

### 代码实现

```typescript
function firstMissingPositive(nums: number[]): number {
    const n = nums.length;

    // Step 1: 原地置换
    for (let i = 0; i < n; i++) {
        while (
            nums[i] > 0 &&
            nums[i] <= n &&
            nums[nums[i] - 1] !== nums[i]
        ) {
            // 把 nums[i] 放到正确的位置 nums[nums[i] - 1]
            const correctIndex = nums[i] - 1;
            [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];
        }
    }

    // Step 2: 找第一个不符合 nums[i] === i + 1 的位置
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1;
        }
    }

    // 所有位置都符合，则说明缺失的是 n + 1
    return n + 1;
}
```

### 复杂度分析

| 类型 | 复杂度                          |
| ---- | ------------------------------- |
| 时间 | O(n) ，最多每个元素交换一次     |
| 空间 | O(1) ，原地操作，不使用额外数组 |

## 解法二：原地标记（哈希）

### 核心思想

直接用数组自身当作哈希表，**通过将元素对应索引的值取负**，来表示「某个正整数是否出现过」。

### 步骤分解

1. **预处理：把所有非正数变为 n+1**，因为不关心 <= 0 的数，也不关心 > n 的数，所以统一换掉它们：

   ```js
   if (nums[i] <= 0) nums[i] = n + 1
   ```

2. **遍历数组，将出现过的数 nums[i] 对应的位置 `nums[nums[i] - 1]` 取负**，说明这个数 `num` 出现过：

   ```js
   nums[num - 1] = -Math.abs(nums[num - 1])
   ```

3. **最后扫描整个数组，找到第一个正数位置 i，那么 i+1 是缺失的数**

### 代码实现

```typescript
function firstMissingPositive(nums: number[]): number {
    const n = nums.length
    for (let i = 0; i < n; i++) {
        if (nums[i] <= 0) nums[i] = n + 1
    }
    for (let i = 0; i < n; i++) {
        const num = Math.abs(nums[i])
        if (num <= n) {
            nums[num - 1] = -Math.abs(nums[num - 1])
        }
    }
    for (let i = 0; i < n; i++) {
        if (nums[i] > 0) return i + 1
    }
    return n + 1
};
```

### 复杂度分析

跟[解法一](#解法一：原地置换（桶排序思想）)一样，都是 O(n) 时间 + O(1) 空间的最优解，但实现细节影响性能，原地标记法通过“打标签”的实现方式，在 JavaScript/TypeScript 环境下通常比置换法更高效。

