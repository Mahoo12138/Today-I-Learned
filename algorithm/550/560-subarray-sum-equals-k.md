# [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k)

#leetcode/hash  #leetcode/hash   #leetcode/prefix-sum
## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
解释: [1,1] 和 [1,1] 都是满足条件的子数组
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
解释: [1,2] 和 [3] 都是满足条件的子数组
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

## 题目解析

题目还是比较容易理解的，但是有两点需要注意：

+ **子数组** 必须是 **连续** 的。

+ **不能使用排序**，因为顺序是固定的。

## 暴力解法（O(n²))

最直接的方法是 **枚举所有子数组**：

- 枚举所有起点 `i`，然后从 `i` 开始计算 `sum[i:j]`，检查是否等于 `k`。
- 外层循环 **O(n)**，内层循环 **O(n)**，总体时间复杂度 O(n²)**，在 `n` 较大时会超时。

```typescript
function subarraySum(nums: number[], k: number): number {
    let count = 0;
    for (let i = 0; i < nums.length; i++) {
        let sum = 0;
        for (let j = i; j < nums.length; j++) {
            sum += nums[j];
            if (sum === k) count++;
        }
    }
    return count;
}
```

## 前缀和 + 哈希表优化（O(n))

### 什么是前缀和？

前缀和可以简单理解为「数列的前 n 项的和」，是一种重要的预处理方式，能大大降低查询的时间复杂度。

**举个生活例子 🌰**

假设你每天都会往存钱罐里存钱，记录每天存的钱数：

- 第 1 天存 1 元
- 第 2 天存 2 元
- 第 3 天存 3 元
- 第 4 天存 4 元

你想快速回答类似这种问题：**从第 2 天到第 4 天，一共存了多少钱？**

传统做法是：2+3+4=9 元，需要遍历这几天的记录。但如果我们提前计算一个「前缀和数组」：

| 天数 | 前缀和 | 说明                                |
| :--- | :----- | ----------------------------------- |
| 0    | 0      | ← 初始值，表示第0天之前没有存钱     |
| 1    | 1      | ← 第 1 天结束时总共有 1元           |
| 2    | 3      | ← 第 2 天结束时总共有 1+2=3 元      |
| 3    | 6      | ← 第 3 天结束时总共有 1+2+3=6 元    |
| 4    | 10     | ← 第 4 天结束时总共有 1+2+3+4=10 元 |

现在要计算第 2 天到第 4 天的总和，只需要用 **第 4 天的前缀和 - 第 1 天的前缀和**：

```
10（第4天总和） - 1（第1天总和） = 9元
```

**前缀和的作用：用两个时间点的“总量差”快速计算某段时间的“增量”**。

### **核心思路**

+ **定义前缀和**：`sum[i]` 表示从第 0 个元素到第 i 个元素的和（即前 i+1 个元素的和）。
+ **子数组和与前缀和的关系**：子数组 `nums[j..i]` 的和等于 `sum[i] - sum[j-1]`。
  - 例如，`nums = [1, 2, 3]`，子数组 `[2,3]` 的和是 `sum[2] - sum[0] = 6 - 1 = 5`。
+ **问题转化**：我们需要找到满足 `sum[i] - sum[j] = k` 的 i 和 j 的组合数量。

- **优化：用哈希表记录历史前缀和**
  - 如果我们遍历数组，每次计算当前的前缀和 `currentSum`，并检查之前是否存在前缀和等于 `currentSum - k`，那么这些历史前缀和对应的位置到当前位置的子数组和就是 k。
  - 用一个哈希表 `prefixSumMap` 来记录每个前缀和出现的次数。

### 代码实现

```typescript
function subarraySum(nums: number[], k: number): number {
    const prefixSumMap = new Map<number, number>();
    prefixSumMap.set(0, 1); // 初始前缀和为 0 出现一次
    let currentSum = 0;
    let count = 0;

    for (const num of nums) {
        currentSum += num;
        // 检查是否存在前缀和为 currentSum - k，存在则累加次数
        if (prefixSumMap.has(currentSum - k)) {
            count += prefixSumMap.get(currentSum - k)!;
        }
        // 更新当前前缀和的次数
        prefixSumMap.set(currentSum, (prefixSumMap.get(currentSum) || 0) + 1);
    }

    return count;
};
```

> **为什么初始时要设置 `prefixSumMap.set(0, 1)`？**
>
> 假设存在一个子数组从数组的起始位置开始，例如 `nums = [2]`, k=2：
>
> - `currentSum = 2`
> - `currentSum - k = 0`，哈希表中需要存在 0 才能计数。
>   初始化的 `{0:1}` 正是为了处理这种情况。

### 举例解析

以 `nums = [1, 1, 1], k = 2` 为例：

1. 初始化 `prefixSumMap = {0: 1}`（表示前缀和为 0 出现了 1 次）。
2. 遍历数组：
   - **第 1 个元素 1**：
     - `currentSum = 1`
     - 检查是否存在 `1 - 2 = -1`，哈希表中没有 -1 → 不累加计数。
     - 更新哈希表：`{0:1, 1:1}`
   - **第 2 个元素 1**：
     - `currentSum = 2`
     - 检查是否存在 `2 - 2 = 0`，哈希表中有 0 出现 1 次 → 计数+1。
     - 更新哈希表：`{0:1, 1:1, 2:1}`
   - **第 3 个元素 1**：
     - `currentSum = 3`
     - 检查是否存在 `3 - 2 = 1`，哈希表中有 1 出现 1 次 → 计数+1。
     - 更新哈希表：`{0:1, 1:1, 2:1, 3:1}`
3. 最终计数为2，对应子数组 `[1,1]` 和 `[1,1]`（其实是两个不同的位置）。

### 总结

1. **前缀和**：通过维护前缀和数组，可以将子数组和的计算转化为两个前缀和的差值。
    
2. **哈希表优化**：利用哈希表快速查找所需的前缀和是否存在，并记录其出现次数，避免重复计算。
    
3. **初始条件**：需要初始化前缀和为0的情况，以处理从数组起始位置开始的子数组。

前缀和就像一个“累计积分”，而哈希表帮我们快速查找历史记录。**通过将问题转化为“找两个前缀和的差等于 k”，我们避免了重复计算子数组和，将时间复杂度从O(n²) 优化到 O(n)**。

这种方法不仅能处理正数，还能处理包含负数或零的数组，因为它不依赖数组的单调性，只关心差值的存在性。