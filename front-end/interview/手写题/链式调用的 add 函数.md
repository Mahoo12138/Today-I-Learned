## 题目

实现一个有 sum 功能，无限调用的 add 函数，例： `add(1, 2, 3).sum();` 和 `add(1)(2, 3).sum();` 和 `add(1, 2)(3).sum();` 输出一样的结果。

## 思考方向

1. **链式调用**：函数需要每次调用后返回自身，以便继续接收参数。
2. **参数累积**：每次调用时收集参数并保存，直到调用`sum`时计算总和。
3. **闭包应用**：利用闭包保存参数数组，确保不同调用链之间的参数独立。
4. **函数对象**：通过给函数添加`sum`方法，使其可以被调用。

## 解答示例

```js
function add(...firstArgs) {
  const args = [...firstArgs];
  const fn = (...nextArgs) => {
    args.push(...nextArgs);
    return fn;
  };
  fn.sum = () => args.reduce((acc, curr) => acc + curr, 0);
  return fn;
}
```

## 总结与扩展

1. **闭包与链式调用**：通过闭包保存参数，函数返回自身实现链式调用。
2. **函数对象特性**：函数作为对象可添加方法（如`sum`），结合闭包实现状态保持。
3. **参数处理**：利用剩余参数（`...args`）简化参数收集，适应不定长参数场景。

**类似问题**

- 实现支持链式调用的延迟计算函数（如`add(1)(2).delay(1000).sum()`）。
- 实现链式调用且支持多种运算（如加减乘除）。
- 实现可撤销操作的链式调用（如`undo()`撤销上一次参数添加）。