---
title: 75. 颜色分类
---
# [75. 颜色分类](https://leetcode.cn/problems/sort-colors)

## 题目描述

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**

**输入**：nums = [2,0,2,1,1,0]
**输出**：[0,0,1,1,2,2]

**示例 2：**

**输入**：nums = [2,0,1]
**输出**：[0,1,2]

**提示：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

**进阶：**

- 你能想出一个仅使用常数空间的一趟扫描算法吗？



## 解法一：计数排序

### 核心思想

这题的值域是固定的、非常小：只包含 `0、1、2` 三种值。

我们可以这样做：

1. **第一遍遍历**：数一数数组中有多少个 `0`、`1`、`2`
2. **第二遍遍历**：重新填回数组，先填 `0` 再填 `1`，最后填 `2`

### 代码实现

```typescript
function sortColors(nums: number[]): void {
    const count = [0, 0, 0]; // count[0] 是 0 的个数，count[1] 是 1 的，count[2] 是 2 的

    for (const num of nums) {
        count[num]++;
    }

    let index = 0;
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < count[i]; j++) {
            nums[index++] = i;
        }
    }
}
```

### 复杂度分析

| 项目 | 复杂度                    |
| ---- | ------------------------- |
| 时间 | `O(n)` – 两次遍历         |
| 空间 | `O(1)` – 常数数组长度为 3 |

## 解法二：双指针（荷兰国旗算法）

> 这个经典解法叫做：**荷兰国旗问题（Dutch National Flag Problem）**，由著名计算机科学家 Edsger Dijkstra 提出。

### 核心思想

数组被分成三个部分：

```
[0 区][1 区][2 区]
```

用三个指针管理它：

| 名称   | 作用                       | 初始位置 |
| ------ | -------------------------- | -------- |
| `low`  | 0 区末尾（表示前面全是 0） | 0        |
| `i`    | 当前扫描到的元素           | 0        |
| `high` | 2 区开头（表示后面全是 2） | n - 1    |

用三个区域划分数组后：

```
[0, ..., low-1]      都是 0（红色）
[low, ..., i-1]      都是 1（白色）
[i, ..., high]       未处理
[high+1, ..., n-1]   都是 2（蓝色）
```

从左向右扫描（控制指针 `i`），遇到：

**nums[i] == 0**：

- 应该放到最左边
- 和 `low` 位置交换，然后 `low++`，`i++`

**nums[i] == 1**：

- 正确的中间区域，啥都不做，直接 `i++`

**nums[i] == 2**：

- 应该放到最后
- 和 `high` 位置交换，`high--`，但 `i` **不动**！（新换来的数还没检查）

### 代码实现

```typescript
function sortColors(nums: number[]): void {
    let low = 0, i = 0, high = nums.length - 1;

    while (i <= high) {
        if (nums[i] === 0) {
            [nums[i], nums[low]] = [nums[low], nums[i]];
            i++;
            low++;
        } else if (nums[i] === 1) {
            i++;
        } else { // nums[i] === 2
            [nums[i], nums[high]] = [nums[high], nums[i]];
            high--; // 不移动 i，因为交换过来的可能是 0
        }
    }
}
```

### 实例执行分析

举个完整例子：`[2, 0, 2, 1, 1, 0]`

| i    | nums[i] | 操作                            | 交换后数组           | low  | high |
| ---- | ------- | ------------------------------- | -------------------- | ---- | ---- |
| 0    | 2       | 交换 `i` 与 `high=5`，high--    | `[0, 0, 2, 1, 1, 2]` | 0    | 4    |
| 0    | 0       | 交换 `i` 与 `low=0`，low++，i++ | `[0, 0, 2, 1, 1, 2]` | 1    | 4    |
| 1    | 0       | 交换 `i` 与 `low=1`，low++，i++ | `[0, 0, 2, 1, 1, 2]` | 2    | 4    |
| 2    | 2       | 交换 `i` 与 `high=4`，high--    | `[0, 0, 1, 1, 2, 2]` | 2    | 3    |
| 2    | 1       | 正确位置，i++                   | `[0, 0, 1, 1, 2, 2]` | 2    | 3    |
| 3    | 1       | 正确位置，i++                   | `[0, 0, 1, 1, 2, 2]` | 2    | 3    |
| 4    | -       | i > high，结束                  | ✅ 已排序完           |      |      |

为什么在 `nums[i] === 2` 不移动 i ，这里举个实例 `[1,2,0]`：
| i    | nums[i] | 操作                            | 交换后数组           | low  | high |
| ---- | ------- | ------------------------------- | -------------------- | ---- | ---- |
| 0    | 1       | i++ | `[1,2,0]` |0|2|
| 1 | 2 | 交换 `i` 与 `high=2`，high-- | `[1,0,2]` |0|1|
| 1 | 0 | 交换 `i` 与 `low=0`，low++，i++ | `[0,1,2]` |1|1|
| 2 | - | i > high，结束 | ✅ 已排序完 |||

关键就是第二步移动，将 2 和 0 交换后，此时 0 在 i 的位置上，如果此时 i++ 则会跳过，不对 0 进行扫描了，造成排序错误。

### 复杂度分析

| 项目 | 复杂度                        |
| ---- | ----------------------------- |
| 时间 | `O(n)` — 只遍历一遍数组       |
| 空间 | `O(1)` — 原地操作，无额外数组 |