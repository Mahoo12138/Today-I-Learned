Go使用SQL与类SQL数据库的惯例是通过标准库 [database/sql](http://golang.org/pkg/database/sql/)。这是一个对关系型数据库的通用抽象，它提供了标准的、轻量的、面向行的接口。

## 概述

在Go中访问数据库需要用到`sql.DB`接口：它可以创建语句(statement)和事务(transaction)，执行查询，获取结果。

对于`sql.DB`，首先要了解到它并不是数据库连接，也并未在概念上映射到特定的数据库(Database)或模式(schema)。它只是一个接口和数据库实体的抽象，这个数据库可能是各种各样的，例如一个本地文件、通过网络连接访问的远程数据库，或者是一个内存中的数据库。

`sql.DB` 在后台为你执行以下重要的事情：

+ 操作具体的驱动打开/关闭实际底层数据库的连接；
+ 按需管理连接池，可能有之前提到的多种情形；

`sql.DB` 抽象的设计目的是让您不必担心如何管理对底层数据存储的并发访问。当您使用连接执行任务时，连接将被标记为正在使用，当不再使用时，连接将返回到可用池。这样做的一个后果是，如果您未能将连接释放回池，则可能导致`sql.DB`打开大量连接，可能会耗尽资源(太多连接、太多打开的文件句柄、缺乏可用的网络端口等)。稍后我们将对此进行更多讨论。

在创建`sql.DB`之后，您可以使用它来查询它所表示的数据库，以及创建语句和事务。

## 引入数据库驱动

使用数据库时，除了`database/sql`包本身，还需要引入想使用的特定数据库驱动。

你通常不应该直接使用数据库驱动，尽管有些驱动鼓励你那样做（在我看来，这是个错误的想法）。相反，如果可能的话，你的代码应该只引用定义在包 `database/sql` 的类型。这有助于避免你的代码依赖于这个驱动，以至于你可以以很小的代码修改就可更换底层的数据库驱动（也就是你要访问的数据库）。这也强制你使用 go 的惯用语法，而不是特定驱动的作者提供的惯用语法。

在本文档中，我们使用出自 @julienschmidt 和 @arnehormann 优秀的 [MySQL drivers](https://github.com/go-sql-driver/mysql) 为例。

首先，我们将相关依赖导入到 go 源文件中：

```go
import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)
```

注意到，我们是匿名加载数据库驱动的，即将它的包名的别名设置为 `_`，所以它导出的名称对我们是不可见的。在底层，该驱动会将其自身注册到 `database/sql`包中，通常情况下，除了 `init` 函数运行，其他任何事情都不会发生。

现在可以准备访问一个数据库了。

## 访问数据库

现在我们载入了数据库驱动，正准备创建一个数据库对象，即一个 `sql.DB`。为此，你可以使用 `sql.Open`。它会返回一个 `*sql.DB`。

```go
func main() {
	db, err := sql.Open("mysql",
		"user:password@tcp(127.0.0.1:3306)/hello")
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
}
```

在上面的例子中，我们说明几件事情：

1. `sql.OPEN` 的第一个参数是驱动名，这是一个驱动被用于将其自身注册到 `database/sql`中的字符串，按照惯例，它会与包名保持一直以避免歧义。例如， `mysql` 对应着 [github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)。某些驱动不会遵循该惯例使用数据库名称，例如 `sqlite3`包名为 [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3) 以及`postgres`是 [github.com/lib/pq](https://github.com/lib/pq)。
2. 第二个参数是驱动特定的语法，将向驱动表明如何访问底层数据库。在例子中，我们将连接到本地 Mysql 数据库实例中的 `hello` 数据库。
3. 你应该（几乎）总是对所有 `database/sql` 操作返回结果，做检测和处理错误。只有很少一些特殊情况，这样做是没有意义的， 我们将在后面讨论。
4. 如果 `sql.DB` 没有一个生命周期超出当前函数作用域，那么通常会使用`defer db.Close()`。

可能与直觉相反，`sql.OPEN` 不会建立任何与数据库的连接，也不会验证驱动连接的参数。它只是简单地为后续将使用的数据库做了抽象。底层数据库第一个实际的连接将会被懒加载式地建立，即当它首次被需要的时候。如果你想要立即检测数据库的可用性和可访问性（例如可以建立网络连接以及登录），可使用 `db.Ping`，不过要记住检测错误：

```go
err = db.Ping()
if err != nil {
	// do something here
}
```

当操作完数据库时，虽然习惯上使用 `Close()`关闭，但是 `sql.DB` 对象是为了长连接而设计的，不要频繁`Open()`和`Close()`数据库。应该为每个不同的待访问数据库创建一个 `sql.DB`实例，并在用完前一直保留它。需要时可将其作为参数传递，或注册为全局对象，但是要让其保持开启状态。且不要在短链接函数中 `Open()` 或`Close()`，也应该将 `sql.DB`作为参数传入其中。

如果你不把`sql.DB`当成长期对象来用而频繁开关启停，就可能遭遇各式各样的错误：无法复用和共享连接，耗尽网络资源，由于TCP连接保持在`TIME_WAIT`状态而间断性的失败等……这些问题就是没有按照`database/sql`设计的意图使用的标志。

现在是时候使用你的 `sql.DB` 对象了。

## 检索结果集合

有许多种惯用的从数据库检索数据结果的操作：

+ 执行查询返回多行；
+ 准备一个语句重复使用，执行多次并销毁它；
+ 以一次性的方式执行语句，而不准备重复使用；
+ 执行查询返回单行，这是特殊情况的快捷方式。

Go 的 `database/sql` 函数名称是重要的。如果一个函数名称包含 `Query`，那么它是被设计为向数据库查询的，会返回多行，即使它是空的。不返回多行的语言不应该使用 `Query` 函数，而应该使用 `Exec()`。

 ### 获取数据

让我们看一个如何查询数据库的例子，我们从 `users` 表中查询一个 id 为 1 的 user，然后输出它的 id 和 name。我们将使用 `rows.Scan()`把结果一次一行分配到变量中。

```go
var (
	id int
	name string
)
rows, err := db.Query("select id, name from users where id = ?", 1)
if err != nil {
	log.Fatal(err)
}
defer rows.Close()
for rows.Next() {
	err := rows.Scan(&id, &name)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(id, name)
}
err = rows.Err()
if err != nil {
	log.Fatal(err)
}
```

以下是上述代码所作的事情：

+ 我们使用 `db.Query()` 发送查询请求到数据库，通常要检查错误；
+ 延迟执行 `db.Close()`，这非常重要；
+ 使用 `rows.Next()` 遍历这些行；
+ 通过`rows.Scan()`读取这些行中的列，到变量中；
+ 遍历完列后，检查错误；

这几乎是在Go中实现它的唯一方法。例如，你不能将列当作一个 map。这是因为所有东西都是强类型的。你需要创建正确的类型的变量并向他们传递指针，如上所示。

其中有几个部分很容易出错，可能会产生不好的后果。

+ 在 `for rows.Next()` 循环中，需要每次检查错误。如果有错误发生，你需要知晓。不要仅仅假设循环会迭代直到处理完所有行。
+ 其次，只要有一个 open 的结果集（rows 表示的），底层的连接则是 busy 的，不能用于其他查询。意味着它在连接池中是不可用的。如果你使用 `rows.Next()` 迭代所有的列数据，最终你读到最后一行，接着  `rows.Next()` 将遇到 一个内部的 EOF 错误，会为你调用 `rows.Close()`函数。但是某些原因下，你退出了循环，即更早返回等，然后 `rows` 不会关闭，所以连接仍然保持 open 状态。（如果 `rows.Next()`由于错误返回 false，它会自动关闭）。这是一个轻易耗尽资源的方式。
+ 如果 `rows`已经关闭，那么 `rows.Close()` 将是无害的空操作，所以你可以调用它多次。注意，我们首先检查错误，并仅在没有错误时调用 `rows.Close()`，以避免运行时 panic。
+ 应该总是使用 `defer rows.Close()`，即使你也在循环最后显性地调用了 `rows.Close()`，这也不是个坏主意；
+ 不要在循环中 `defer`。一个 `deferred` 的语句不会执行直到这个函数退出时，所以一个长时间运行的函数不应该使用它。如果你这样做，你将缓慢地积累内存。如果你重复地在循环中查询和消费结果集，应该在处理完成每一个结果时，显式地调用 `rows.Close()` ，而不是使用 `defer`。

### Scan() 原理

当你遍历每一行且将其 `scan` 到目标变量时，Go 在幕后为你执行数据类型转为工作。这基于目标变量的类型。意识到这一点能简化你的代码并帮助你避免重复性的工作。

例如，假设你从表中选择了一些行，表中定义了字符串类型的列，例如`VARCHAR(45)`之类的。然而，你可能知道，表中总是包含数字。如果你传一个指针给字符串，Go 将复制这个字节转化为字符串。现在，你能使用 `strconv.ParseInt()` 或类似的将转化值转化为数字的方式。你将不得不检测 SQL 操作的错误，以及转化为整型的错误。这是麻烦又枯燥的。

