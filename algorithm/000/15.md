---
title: 15. 三数之和
tags:
  - "#leetcode/two-pointer"
  - "#leetcode/sort"
  - "#leetcode/array"
leetcode: medium
---
# [15. 三数之和](https://leetcode.cn/problems/3sum)

## 题目描述

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`
## 读懂题目

题目要求我们找出数组中所有满足以下条件的三元组：

- 三个数的和为 0，即 `nums[i] + nums[j] + nums[k] = 0`。
- `i`, `j`, `k` 是不同的索引，即 `i != j != k`。
- 结果中不能有重复的三元组。

## **暴力解法（O(n³))**

最直接的暴力解法就是使用三重循环，遍历所有可能的三元组组合，判断它们是否满足条件：

- 每次取三个不同的元素，计算它们的和，若为零，则记录该三元组。
- 由于存在重复的三元组（比如不同的顺序），需要对结果去重。

这种方法的时间复杂度是 O(n³)，非常低效，当数组的长度很大时，暴力解法会非常慢。

## **优化思路：双指针法（O(n²))**

我们可以通过排序和双指针来优化解法。优化的关键是：

- 首先对数组进行排序，这样我们就可以通过双指针来有效地找三数之和。
- 排序后，可以利用 **双指针** 方法来避免重复的三元组。
- 具体思路是：固定一个数，然后用双指针来查找另外两个数，使得这三个数的和为零。

#### 详细步骤：

1. **排序**：首先将数组排序，这样可以方便地进行去重操作和使用双指针。
2. **固定一个数**：用一个循环固定数组中的一个数 `nums[i]`，然后在剩余的部分用双指针找另外两个数。
3. **双指针**：设定两个指针，一个从 `i+1` 开始，另一个从数组的末尾开始。每次移动两个指针，直到找到一组三个数的和为零。
4. **去重**：需要避免重复的三元组，可以通过跳过相同的元素来实现。

## **具体实现**

```typescript
function threeSum(nums: number[]): number[][] {
    // 排序数组
    nums.sort((a, b) => a - b);
    const result: number[][] = [];
    
    // 遍历数组
    for (let i = 0; i < nums.length - 2; i++) {
        // 跳过重复的元素
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        
        // 双指针初始化
        let left = i + 1, right = nums.length - 1;
        
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];
            
            if (sum === 0) {
                // 找到一个三元组
                result.push([nums[i], nums[left], nums[right]]);
                left++;
                // 跳过重复的元素
                while (left < right && nums[left] === nums[left - 1]) {
                    left++;
                }
                right--;
                while (left < right && nums[right] === nums[right + 1]) {
                    right--;
                }
            } else if (sum < 0) {
                // 如果和小于 0，说明左指针需要向右移动
                left++;
            } else {
                // 如果和大于 0，说明右指针需要向左移动
                right--;
            }
        }
    }
    
    return result;
}
```

## **思路解释**

- **排序**：排序数组使得相同的元素聚集在一起，可以方便去重。
- **固定一个元素**：我们通过外层循环固定一个数 `nums[i]`，然后在剩下的部分通过双指针法来寻找两个数，使得 `nums[i] + nums[left] + nums[right] = 0`。
- **双指针查找**：用两个指针，一个从 `i+1`开始，另一个从数组的末尾开始，通过移动指针来寻找满足和为零的两数之和，因为数组是有序的：
  - 如果当前三数之和 `sum` 小于 0，说明需要增加 `left` 指针指向的数，左移。
  - 如果 `sum` 大于 0，说明需要减少 `right` 指针指向的数，右移。
- **去重**：
  - **跳过元组中重复的第一个元素**：当遇到 `nums[i] === nums[i-1]` 时，跳过这个位置，避免重复三元组。
  - **跳过元组中重复的第二个和第三个元素**：当 `nums[left] === nums[left + 1]` 或者 `nums[right] === nums[right - 1]` 时，分别跳过这些重复的元素，保证不重复计算。

### **时间复杂度分析**

- **排序复杂度**：首先对数组排序，时间复杂度为 `O(nlogn)`。
- **双指针遍历复杂度**：对于每一个 `i`，我们都用双指针法扫描剩余的部分，双指针扫描的时间复杂度为 O(n)，因此总时间复杂度为 O(n²)。

所以总体时间复杂度是 **O(n²)**，比暴力解法的 O(n³) 要高效得多。

### **空间复杂度分析**

- **空间复杂度**：我们只使用了一个 `result` 数组来存储答案，因此空间复杂度是 **O(n)**，其中 `n` 是存储结果所需的空间。

