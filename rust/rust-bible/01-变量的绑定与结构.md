## 手动设置变量可变性

支持声明可变的变量，要么只支持声明不可变的变量( 例如函数式语言 )，前者为编程提供了**灵活性**，后者为编程提供了**安全性**，而 Rust 比较野，选择了两者我都要，既要灵活性又要安全性。

运行性能上的提升，因为将本身无需改变的变量声明为不可变在运行期会**避免一些多余的 `runtime` 检查**。

## 变量绑定

`let a = "hello world"` 在 Rust 中称为**变量绑定**，涉及 Rust 最核心的原则——**所有权**。

## 变量可变性

Rust 的变量在默认情况下是**不可变的**，可通过 `mut` 关键字让变量变为**可变**。

一个变量往往被多处代码所使用，其中一部分代码假定该变量的值永远不会改变，而另外一部分代码却无情的改变了这个值，在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。

只有你想让你的变量改变时，它才能改变，这样就不会造成心智上的负担，也给别人阅读代码带来便利。

## 下划线忽略变量

```rust
fn main() {
    let _x = 5;
    let y = 10;
}
```

## 变量解构

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);	// tuple 元组
    // a = true,不可变; b = false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

在 [Rust 1.59](https://course.rs/appendix/rust-versions/1.59.html) 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。

## 变量和常量间的差异

- 常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
- 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。

## 变量遮蔽

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的；

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以**重复的使用变量名字**，而不用绞尽脑汁去想更多的名字