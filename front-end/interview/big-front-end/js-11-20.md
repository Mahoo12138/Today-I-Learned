## 11. what is Composition? create a pipe()

ç°åœ¨éœ€è¦ä½ è‡ªå·±å†™ä¸€ä¸ª`pipe()` æ–¹æ³•ã€‚

å‡è®¾æœ‰ä¸€äº›ç®€å•çš„å››åˆ™è¿ç®—æ–¹æ³•ï¼š

```js
const times = (y) =>  (x) => x * y
const plus = (y) => (x) => x + y
const subtract = (y) => (x) => x - y
const divide = (y) => (x) => x / y
```

`pipe()` å¯ä»¥ç”¨æ¥ç”Ÿæˆæ–°çš„è®¡ç®—æ–¹å¼

```js
pipe([
  times(2),
  times(3)
])  
// x * 2 * 3

pipe([
  times(2),
  plus(3),
  times(4)
]) 
// (x * 2 + 3) * 4

pipe([
  times(2),
  subtract(3),
  divide(4)
]) 
// (x * 2 - 3) / 4
```

**æ³¨æ„**

1. ä¸ºäº†ç®€å•ï¼Œå¯ä»¥å‡è®¾ä¼ ç»™`pipe()`çš„æ–¹æ³•éƒ½åªæœ‰ä¸€ä¸ªå‚æ•°

```js
function pipe(funcs) {
	return (x) => {
		let result = x
		if(funcs.length > 0){
			funcs.forEach(f => result = f(result))
		}
		return result;
	}
}
```

## 12. arguments

What does the code snippet to the right output byÂ `console.log`?

```js
function log(a,b,c,d) {
Â  console.log(a,b,c,d)
Â  arguments[0] = 'bfe'
Â  arguments[3] = 'dev'
Â  console.log(a,b,c,d)
}

log(1,2,3)
```

[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)Â æ˜¯ä¸€ä¸ªåŒ…å«äº†ä¼ é€’ç»™å‡½æ•°çš„å‚æ•°çš„ç±»æ•°ç»„å¯¹è±¡ï¼Œ**ç±»æ•°ç»„**æ„å‘³ç€Â `arguments`Â æœ‰é•¿åº¦å±æ€§ï¼Œå¹¶ä¸”å±æ€§çš„ç´¢å¼•æ˜¯ä»é›¶å¼€å§‹çš„ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰Â `Array` çš„å†…ç½®æ–¹æ³•ï¼Œä¸è¿‡å¯ä»¥è°ƒç”¨ `Array` åŸå‹ä¸Šçš„æ–¹æ³•ï¼Œæ­¤å¤–å¦‚æœè°ƒç”¨çš„å‚æ•°å¤šäºæ­£å¼å£°æ˜æ¥å—çš„å‚æ•°ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç¤ºä¾‹ï¼š

```js
function myConcat(separator) {
  var args = Array.prototype.slice.call(arguments, 1);
  return args.join(separator);
}


// returns "red, orange, blue"
myConcat(", ", "red", "orange", "blue");
// returns "elephant; giraffe; lion; cheetah"
myConcat("; ", "elephant", "giraffe", "lion", "cheetah");
```

Â `arguments` åœ¨å‡½æ•°ä¸­ï¼Œå¯ä»¥è¿›è¡Œèµ‹å€¼æ›´æ–°ï¼Œä½†æ˜¯é€šè¿‡ç´¢å¼•è¿›è¡Œèµ‹å€¼æ—¶ï¼Œ**å¦‚æœæ˜¯æ²¡æœ‰ä¼ å‚çš„å½¢å‚ä½ç½®ï¼Œæ˜¯ä¸èƒ½æ›´æ–°èµ‹å€¼çš„**ï¼Œæ‰€ä»¥ä¸Šé¢çš„è¾“å‡ºåº”è¯¥æ˜¯ï¼š

```text
1,2,3,undefined
"bfe",2,3,undefined
```

## 13. Operator precedence

What does the code snippet to the right output byÂ `console.log`?

```js
console.log(0 == 1 == 2) // false == 2 ğŸ‘‰ğŸ» 0 == 2 ğŸ‘‰ğŸ» false
console.log(2 == 1 == 0) // false == 0 ğŸ‘‰ğŸ» 0 == 0 ğŸ‘‰ğŸ» true
console.log(0 < 1 < 2)   // true < 2 ğŸ‘‰ğŸ» 1 < 2 ğŸ‘‰ğŸ» true
console.log(1 < 2 < 3)   // true < 3 ğŸ‘‰ğŸ» 1 < 3 ğŸ‘‰ğŸ» true
console.log(2 > 1 > 0)   // true > 0 ğŸ‘‰ğŸ» 1 > 0 ğŸ‘‰ğŸ» true
console.log(3 > 2 > 1)   // true > 1 ğŸ‘‰ğŸ» 1 > 1 ğŸ‘‰ğŸ» false
```

è¿™é‡Œçš„ä¸€ä¸ªé‡è¦ç»†èŠ‚æ˜¯ï¼Œå¦‚æœä¸€ä¸ªæ“ä½œæ•°æ˜¯å¸ƒå°”å€¼ï¼Œå¦ä¸€ä¸ªæ˜¯æ•°å­—ï¼Œåˆ™ä¼šå…ˆå°†å¸ƒå°”å€¼è½¬æ¢ä¸ºæ•°å­—ç±»å‹ã€‚ `true` è¢«è½¬æ¢ä¸ºæ•°å­— 1ï¼Œ `false` è¢«è½¬æ¢ä¸ºæ•°å­— 0ã€‚

è¿™æ˜¯é€šè¿‡ ECMAScript çš„è§„èŒƒä¸­å®šä¹‰çš„æŠ½è±¡ç›¸ç­‰æ¯”è¾ƒç®—æ³•ï¼ˆAbstract Equality Comparisonï¼‰å®ç°çš„ï¼Œå…¶ä¸­ä¸»è¦æ˜¯å¯¹ boolean åšäº† [ToNumber](https://tc39.es/ecma262/#sec-tonumber) æ“ä½œï¼š

> **ToNumber (Â argumentÂ )**
>   4. IfÂ argumentÂ is eitherÂ nullÂ orÂ false, returnÂ +0ğ”½.
>   5.Â IfÂ argumentÂ isÂ true, returnÂ 1ğ”½.

## 14. Addition vs Unary Plus

What does the code snippet to the right output byÂ `console.log`?

There is a difference betweenÂ [Addition Operator(+)](https://tc39.es/ecma262/#sec-addition-operator-plus "null")Â andÂ [UnaryÂ plus operator(+)](https://tc39.es/ecma262/#sec-unary-plus-operator "null"), evenÂ thoughÂ they use the same '+'.

```js
console.log(1 + 2) // 3
console.log(1 + + 2) // 1 + (+2) = 1 + 2 = 3
console.log(1 + + + 2) // 1 + (+(+2)) = 1 + 2 = 3
console.log(1 + '2') // "1" + "2" = "12" 
console.log(1 + + '2') // 1 + (+2) = 1 + 2 = 3
console.log('1' + 2) // "1" + "2" = "12"
console.log('1' + + 2) // "1" + (+2) = "1" + 2 = "1" + "2" = "12"
console.log(1 + true) // 1 + 1 = 2
console.log(1 + + true) // 1 + (+true) = 1 + 1 = 2
console.log('1' + true) // "1" + "true" = "1true"
console.log('1' + + true) // "1" + (+true) = "1" + 1 = "1" + "1" = "11"
console.log(1 + null) // 1 + 0 = 1
console.log(1 + + null) // 1 + (+null) = 1 + 0 = 1
console.log('1' + null) // "1" + "null" = "1null"
console.log('1' + + null) // "1" + (+null) = "1" + 0 = "1" + "0" = "10"
console.log(1 + undefined) // 1 + NaN = NaN
console.log(1 + + undefined) // 1 + (+undefined) = 1 + NaN = NaN
console.log('1' + undefined) // "1" + "undefined" = "1undefined"
console.log('1' + + undefined) // "1" + (+undefined) = "1" + NaN = "1" + "NaN" = "1NaN"
console.log('1' + + + undefined) // "1" +(+(+undefined)) = "1" + NaN = "1" + "NaN" = "1NaN"
```

TheÂ unaryÂ plus operator (+)Â å°†å…¶åçš„æ“ä½œæ•°è½¬ä¸ºæ•°å­—ç±»å‹ï¼š

```js
+1 // 1
+"1" // 1
+true // 1
+null // 0
+undefined // NaN
+NaN // NaN
```

Addition operatorÂ `+` å‰çš„æ“ä½œæ•°å¦‚æœä¸ºæ•°å­—ï¼Œåˆ™ä¼šå°†å…¶åçš„æ“ä½œæ•°è½¬ä¸ºæ•°å­—è¿›è¡Œç›¸åŠ ï¼›å¦åˆ™å°†æ‰§è¡Œå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä¹Ÿå°±å°†å…¶åçš„æ“ä½œæ•°è½¬ä¸ºå­—ç¬¦ä¸²ã€‚

## 15. instanceOf

```js
console.log(typeof null);                          
// "object" - 'null' has "object" type in js (backward compatibility)
console.log(null instanceof Object);               
// false - 'null' is primitive and doesn't have 'instanceof' keyword
console.log(typeof 1);                             
// "number" - one of js types
console.log(1 instanceof Number);                  
// false - '1' is primitive and doesn't have 'instanceof' keyword
console.log(1 instanceof Object);                  
// false - same as above
console.log(Number(1) instanceof Object);          
// false - Number(1) === 1 - same as above
console.log(new Number(1) instanceof Object);      
// true - 'new Number(1)' is object, so it's correct
console.log(typeof true);                          
// "boolean" - one of js types
console.log(true instanceof Boolean);              
// false - 'true' is primitive and doesn't have 'instanceof' keyword
console.log(true instanceof Object);               
// false - same as above
console.log(Boolean(true) instanceof Object);      
// false - Boolean(true) === true - same as above
console.log(new Boolean(true) instanceof Object);  
// true - 'new Boolean(true)' is object, so it's correct
console.log([] instanceof Array);                  
// true - '[]' is instanceof Array and Object
console.log([] instanceof Object);                 
// true - '[]' is instanceof Array and Object
console.log((() => {}) instanceof Object);         
// true - if it's not a primitive it's object. So callback is instanceof object
```

+ `Number` å’Œ `Boolean` å‡½æ•°ç›´æ¥è°ƒç”¨åªæ˜¯å°†å‚æ•°è½¬åŒ–ä¸ºç›¸åº”çš„åŸå§‹ç±»å‹ï¼ŒçœŸæ­£çš„åˆ›å»ºåŒ…è£…å¯¹è±¡ï¼Œéœ€è¦ä½¿ç”¨ `new`ï¼Œè¿™ä¸ªç®—æ˜¯ä¸ªæ˜“é”™ç‚¹ï¼›
+ `instanceOf` ä¸»è¦æ˜¯æ£€æŸ¥å¯¹è±¡çš„åŸå‹é“¾ï¼Œå…ˆè·å–å¾…æ£€æŸ¥å¯¹è±¡çš„åŸå‹ï¼ˆ`prototype`ï¼‰ï¼Œç„¶åæ²¿ç€åŸå‹é“¾é€çº§å‘ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°æ‰¾åˆ° `null` æˆ–è€…æ‰¾åˆ°ä¸ç»™å®šæ„é€ å‡½æ•°çš„ `prototype` ç›¸ç­‰çš„åŸå‹ï¼›æ‰€ä»¥å¯¹äº `Array` å®ä¾‹ï¼Œ`[] instanceof Array` å’Œ `[] instanceof Object` éƒ½æ˜¯æˆç«‹çš„ï¼Œéƒ½åœ¨åŸå‹é“¾ä¸Šï¼Œå½“ç„¶`Object` åœ¨ `Array` åï¼›
##  16. parseInt

```js
console.log(['0'].map(parseInt)); // [0]
console.log(['0','1'].map(parseInt)); // [0,NaN]
console.log(['0','1','1'].map(parseInt)); // [0,NaN,1]
console.log(['0','1','1','1'].map(parseInt)); // [0,NaN,1,1]
```

é—®é¢˜çš„å…³é”®å°±æ˜¯ `map` å‡½æ•°çš„å›è°ƒæœ‰ä¸¤ä¸ªå‚æ•°ï¼Œå½“å‰å…ƒç´ å’Œç´¢å¼•å€¼ã€‚

å…¶æ¬¡æ˜¯ `parseInt` ï¼Œç¬¬äºŒä¸ªå‚æ•° *radix*ï¼Œå¦‚æœæ˜¯`0`,Â `NaN`Â æˆ–Â `Infinity`ï¼Œé‚£ä¹ˆä¼šé»˜è®¤ä¸º 10ï¼›å¦‚æœ  radix < 2 æˆ– radix > 36ï¼Œé‚£ä¹ˆå°†è¿”å›Â `NaN`ã€‚

```js
['0','1','1','1'].map(parseInt)

// This actually simplifies to â€” (2nd parameter is the index)
parseInt('0', 0); // 0 is treated as base 10
parseInt('1', 1); // NaN as radix < 2
parseInt('1', 2); // 1 in radix 2  
parseInt('1', 3); // 1 in radix 3
```

## 17. reduce

```js
[1,2,3].reduce((a,b) => {
  console.log(a,b)
});
// 1, 2
// undefined, 3

[1,2,3].reduce((a,b) => {
  console.log(a,b)
}, 0)
// 0,1
// undefined, 2
// undefined, 3
```

## 18. Promise executor II

```js
const p1 = Promise.resolve(1)
const p2 = new Promise((resolve) => resolve(p1))
const p3 = Promise.resolve(p1)
const p4 = p2.then(() => new Promise((resolve) => resolve(p3)))
const p5 = p4.then(() => p4)

console.log(p1 == p2) // false
console.log(p1 == p3) // true
console.log(p3 == p4) // false
console.log(p4 == p5) // false
```

å°½ç®¡ p1~p5 æœ€åéƒ½æ˜¯ `PromiseÂ {<fulfilled>: 1}`ï¼Œä½†æ˜¯åˆ¤æ–­çš„è¿‡ç¨‹ä¸­æ˜¯ä¸ä¸€æ ·çš„ã€‚

å¯¹äº p1 å’Œ p2ï¼Œp1 ä¸º `PromiseÂ {<fulfilled>: 1}`ï¼Œè€Œ p2 ä¸º`PromiseÂ {<pending>}`ï¼ŒPromise æ„é€ æ—¶ä¼ å…¥çš„å‡½æ•°å†…éƒ¨çš„ `resolve`ï¼Œå…¶å‚æ•°åªè¦æ˜¯ Promise æˆ–è€… Â thenable å¯¹è±¡ï¼Œæ‰§è¡Œéƒ½æ˜¯å¼‚æ­¥çš„ï¼Œä¹Ÿå°±æ˜¯ä¼šæœ‰ä¸€ä¸ªæ–°çš„å¾®ä»»åŠ¡å…¥é˜Ÿï¼š

```js
const p1 = Promise.resolve(1)
console.log(0)
const p2 = new Promise((resolve) => {
    console.log(1)
    resolve((console.log(1.5),p1))
    console.log(2)
})
console.log(p1, p2)
void setTimeout(()=>{
    console.log(p1, p2)
})
// 0
// 1
// 1.5
// 2
// PromiseÂ {<fulfilled>: 1} PromiseÂ {<pending>}
// PromiseÂ {<fulfilled>: 1} PromiseÂ {<fulfilled>: 1}
```

p1 å’Œ p2 æœ¬èº«å°±ä¸æ˜¯åŒä¸€ä¸ª promise å¯¹è±¡ï¼Œä¸”çŠ¶æ€è¿˜ä¸ä¸€æ ·ï¼Œä¸å¯èƒ½`==`åˆ¤æ–­ç›¸ç­‰ã€‚

å¯¹äº p1 å’Œ p3ï¼Œ`Promise.resolve` è‹¥ä¼ å…¥çš„æ˜¯ Promise é‚£ä¹ˆå°†ç›´æ¥è¿”å›è¯¥ Promiseï¼Œæ‰€ä»¥ p3 æœ¬è´¨ä¸Šå°±æ˜¯ p1ï¼Œå³ `p1 == p3`ã€‚

å¯¹äº p4ï¼Œåœ¨ p2 ä¸Šè°ƒç”¨äº† thenï¼Œè¿™é‡Œä¼šæœ‰ä¸€ä¸ªå¾®ä»»åŠ¡å…¥é˜Ÿï¼Œä¸ä¼šå›  then çš„ Promise çš„çŠ¶æ€è€Œå½±å“ï¼Œä¸”è¿”å›ä¸€ä¸ªæ–°çš„ Promise å¯¹è±¡ï¼Œè¿™ä¹Ÿä¸å—å†…éƒ¨è¿”å›å€¼çš„å½±å“ï¼ˆ`p2 != p3`ï¼‰ï¼›

```js
let p3 = null
const p1 = Promise.resolve(1)
console.log(0)
const p2 = p1.then(() => {
    console.log(1)
    p3 = new Promise((resolve) => {
        console.log(2)
        resolve(p1)
    })
    console.log(3)
    return p3
})
console.log(4, p1, p2, p3)
setTimeout(()=>{
    console.log(5, p1, p2, p3)
    console.log(p2 == p3)
})

// 0
// 4 PromiseÂ {<fulfilled>: 1}  PromiseÂ {<pending>}      null
// 1
// 2
// 3 PromiseÂ {<fulfilled>: 1}  PromiseÂ {<pending>}      PromiseÂ {<pending>}
// 5 PromiseÂ {<fulfilled>: 1}  PromiseÂ {<fulfilled>: 1} PromiseÂ {<fulfilled>: 1}
// false
```

æ‰€ä»¥ p3ï¼Œp4 å’Œ p5 éƒ½æ˜¯ä¸åŒçš„ promise å¯¹è±¡ã€‚

## 19. `this`

```js
const obj = {
  a: 1,
  b: function() {
    console.log(this.a)
  },
  c() {
    console.log(this.a)
  },
  d: () => {
    console.log(this.a)
  },
  e: (function() {
    return () => {
      console.log(this.a);
    }
  })(),
  f: function() {
    return () => {
      console.log(this.a);
    }
  }
}

console.log(obj.a) // 1
obj.b() // 1
;(obj.b)() // 1
const b = obj.b
b() // undefined
obj.b.apply({a: 2}) // 2
obj.c() // 1
obj.d() // undefined
;(obj.d)() // undefined
obj.d.apply({a:2}) // undefined
obj.e() // undefined
;(obj.e)() // undefined
obj.e.call({a:2}) // undefined
obj.f()() // 1
;(obj.f())() // 1
obj.f().call({a:2}) // 1
```

### Explanation

1. `obj.a`Â simply points to the propertyÂ `a`Â onÂ `obj`ï¼›
2. `obj.b`Â is a normal function and invoking it will log 1ï¼›
3. `(obj.b)()`Â is the same asÂ `obj.b()`ï¼›
4. When we store the reference ofÂ `obj.b`Â in a variable, executing itÂ separatelyÂ loses the reference toÂ `obj`Â and instead will point toÂ `window`Â hence loggingÂ `undefined`ï¼›
5. Because we are usingÂ `apply`Â to explicitlyÂ bindÂ `this`Â toÂ `{a: 2}`Â it logs 2ï¼›
6. `obj.c`Â is also a normal function, logs 1ï¼›
7. `obj.d`Â is anÂ arrowÂ function, hence it willÂ basicallyÂ borrow theÂ scopeÂ from outsideÂ `obj`Â which isÂ `window`ï¼›
8. Same as aboveï¼›
9. `apply`Â will not make any difference forÂ arrowÂ functions and it keeps the originalÂ `this`Â binding i.e.Â `window`ï¼›
10. `obj.e`Â is actually anÂ [IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)Â soÂ `this`Â refers toÂ `window`Â and it returns anÂ arrowÂ function henceÂ `this`Â will take its value from enclosing context i.e. it'll beÂ `window`. LogsÂ `undefined`ï¼›
11. Same as aboveï¼›
12. Once again,Â `call`Â will not make any difference forÂ arrowÂ functions and it keeps the originalÂ `this`Â binding i.e.Â `window`ï¼›
13. `obj.f`Â isÂ similarÂ toÂ `e`Â but main difference is that its a normal function soÂ `this`Â points toÂ `obj`Â inside it. TheÂ arrowÂ function inside takesÂ `this`Â from enclosing context hence referring toÂ `obj`ï¼›
14. Same as aboveï¼›
15. `call`Â will not make any difference forÂ arrowÂ functions and it keeps the originalÂ `this`Â binding i.e.Â `obj`Â and notÂ `{a: 2}`.Â ThusÂ it logs 1ï¼›

### æ€»ç»“
+ this  çš„å€¼å–å†³äºå‡½æ•°å¦‚ä½•è¢«è°ƒç”¨ï¼Œè€Œä¸æ˜¯è¢«å£°æ˜å®šä¹‰çš„ä½ç½®ï¼›
+ apply å’Œ call å¹¶ä¸ä¼šå½±å“ç®­å¤´å‡½æ•°ï¼›
+ IIFE æ‰§è¡Œæ—¶ï¼Œä¸æ˜¯ä½œä¸ºå¯¹è±¡çš„æ–¹æ³•è¢«è°ƒç”¨ï¼Œè€Œæ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å‡½æ•°è°ƒç”¨ï¼Œéä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œç‹¬ç«‹å‡½æ•°ï¼ˆéå‡½æ•°æ–¹æ³•ï¼Œæ„é€ å‡½æ•°ï¼Œäº‹ä»¶å¤„ç†å‡½æ•°ï¼Œæˆ–é€šè¿‡ call å’Œ apply å¤„ç†çš„å‡½æ•°ï¼‰å†…çš„ this éƒ½æ˜¯å…¨å±€å¯¹è±¡ windowï¼›ä¸¥æ ¼æ¨¡å¼ä¸‹åˆ™æ˜¯ undefinedï¼›


## 20. name for Function expression

```js
function a(){
}
const b = function() {
  
}

const c = function d() {
  console.log(typeof d) // "function"
  d = 'e'
  console.log(typeof d) // "function"
}

console.log(typeof a) // "function"
console.log(typeof b) // "function"
console.log(typeof c) // "function"
console.log(typeof d) // "undefined"
c()
```

- `a`Â is aÂ [Function Declaration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)Â and has data typeÂ `function`
- `b`Â andÂ `c`Â areÂ [Function Expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function#description)Â and have data typeÂ `function`
- `d`Â is aÂ [Named Function Expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function#named_function_expression)Â This nameÂ `d`Â is then local only to the function body (scope) hence outside the function bodyÂ `typeof d`Â returnsÂ `undefined`

The special case is inside the named functionÂ `d`.Â **The function name is un-reassignable inside the function**. You can easily see the difference if you run this inÂ `"use strict"`Â mode where it gives an errorÂ `Uncaught TypeError: Assignment to constant variable`. Thus,Â `d`Â will still point to the named functionÂ `d`Â despite being reassigned toÂ `"e"`