---
title: 283. 移动零
tags:
  - "#leetcode/two-pointer"
  - "#leetcode/array"
leetcode: easy
---
# [283. 移动零](https://leetcode.cn/problems/move-zeroes)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

**提示**:

- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`

**进阶**：你能尽量减少完成的操作次数吗？

## 我的解法

```typescript
function moveZeroes(nums: number[]): void {
    let i = 0, j = 0;
    while(i < nums.length) {
        if(nums[i] != 0) {
            while (j > 0 && nums[j - 1] == 0) {
                [nums[j-1], nums[j]] = [nums[j], nums[j-1]];
                j--;
            }
        }
        i++
    }
};
```

### 代码解析

1. **初始化**：你使用了两个指针 `i` 和 `j`，它们都从 0 开始：

   - `i` 用来遍历整个数组，逐一检查每个元素。
   - `j` 用来确保非零元素最终位于数组的前面，并且负责和零交换。

2. **外层 `while` 循环**：这个循环是用来遍历整个数组的

   ```typescript
   while(i < nums.length)
   ```

3. **检查非零元素**：当 `i` 指向的元素不是 0 时，就会执行里面的代码块，交换零到数组的尾部。

   ```typescript
   if(nums[i] != 0)
   ```

4. **内部 `while` 循环**：这个部分的目的是在 `nums[i]` 是非零元素时，检查 `j` 指向的元素前面是否有零。如果是零，就交换它们的位置，将零移到末尾。

   ```typescript
   while (j > 0 && nums[j - 1] == 0) {
       [nums[j-1], nums[j]] = [nums[j], nums[j-1]];
       j--;
   }
   ```

   但这个逻辑上有一个问题，**`j` 其实是在不断往回移**。它的初始值没有被很好地初始化，并且如果交换完成后没有对 `j` 进行有效更新，可能会导致不必要的交换。

5. **指针更新**：`i` 逐步前进，检查下一个元素：

   ```typescript
   i++
   ```

### 代码问题

1. **`j` 指针的管理**
   + `j` 初始为 0，且在每次检查时没有被重置。理论上，`j` 应该始终指向数组中第一个非零元素的位置，而不应该回溯。这个问题可能导致错误的交换操作。
   + 在 `while (j > 0 && nums[j - 1] == 0)` 的条件下，`j` 会倒退，但没有保证 `j` 总是指向有效的交换位置。

2. **`j` 和 `i` 没有协调工作**
   + 如果 `nums[i] != 0`，你通过内层循环去处理零的交换问题。但实际上，这个交换并不完全符合题意：你应该在 `i` 遇到非零时，直接交换非零元素到数组前部，而不是通过反复调整 `j`。
   + 另外，`j` 在你的算法中并未准确地指向应该交换的位置，这样会导致很多不必要的交换。

3. **没有对交换的次数做任何优化**
   + 每次 `nums[i] != 0`，你都可能要执行多个交换，这样的操作不够高效。你可以采用一种更简单的方式，避免频繁交换，直接将非零元素直接移动到前面。

上述 GPT 对我的代码的分析，问题就是，每次遇到非零元素时，左右指针都在该位置（这里左指针 j 应该指向左序列的非零元素的位置），通过回溯所有当前位置之前的非零元素，相互交换位置，这些都是没必要的交换。

## 优化后的解法

```typescript
function moveZeroes(nums: number[]): void {
    let i = 0, j = 0;
    while(i < nums.length) {
        if(nums[i] != 0) {
            nums[j] = nums[i]
            if(i !== j) {
                nums[i] = 0;
            }
            j++
        }
        i++
    }
};
```


## 参考解法

### 方法一：双指针

```typescript
/**
 Do not return anything, modify nums in-place instead.
 */
function moveZeroes(nums: number[]): void {
    let k = 0;
    for (let i = 0; i < nums.length; ++i) {
        if (nums[i]) {
            [nums[i], nums[k]] = [nums[k], nums[i]];
            ++k;
        }
    }
}
```

## 有意思的现象

通过上述两种提交的 LeetCode 执行结果对比，可以发现，`[nums[j], nums[i]] = [nums[i], nums[j]];`的数组交换方式，要比将非零元素直接赋值到 `nums[j]`，然后把 `nums[i]` 置为零，性能更差，这是显而易见的：

赋值操作只涉及到一个判断和两个赋值操作，而利用数组解构的方式，读取 `nums[j]` 和 `nums[i]`，然后重新写入这两个位置，虽然看似简单，但每次交换都涉及到两次数组访问，并且涉及到更多的内存操作；

