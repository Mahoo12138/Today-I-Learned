## 解引用本身（`*` 操作符）

解引用的操作符 `*`，本身的作用是“解开一个引用，获取其指向的值”。但解引用本身并不会改变值的所有权，它只是从引用获取原始值：

```rust
let x = 10; // `x` 是一个 i32 类型的值
let r = &x; // `r` 是对 `x` 的不可变引用

let value = *r; // 解引用 `r`，获取 `x` 的值
```

在这个例子中，`*r` 会解引用 `r`，并将 `x` 的值赋给 `value`。但是，这个解引用并没有改变 `x` 的所有权，`x` 依然在原来的位置，不会被移动。

## 是否复制：与类型是否实现 `Copy` 有关

**复制**发生在 **类型实现了 `Copy` trait** 的情况下。Rust 中的 `Copy` 是一种语义，表示类型的值可以通过简单的位拷贝被复制，而不会改变原值的所有权或造成借用冲突。

#### 例子：`Copy` 类型

```rust
let x = 10; // i32 是 Copy 类型
let r = &x; // `r` 是对 `x` 的引用

let value = *r; // 解引用 `r`，并将 `x` 的值复制到 `value`
```

在上面的代码中，`i32` 类型实现了 `Copy` trait，因此解引用 `*r` 时，会将 `x` 的值 **复制** 给 `value`，而不是移动它。这意味着 `value` 和 `x` 各自拥有一份值，二者互不干扰。

#### 例子：非 `Copy` 类型

```rust
let s = String::from("hello"); // String 不是 Copy 类型
let r = &s; // `r` 是对 `s` 的引用

let value = r.clone(); // clone 是必须的，因为 String 不是 Copy 类型
```

在上面的代码中，`String` 类型不是 `Copy`，因此我们不能直接通过解引用来“复制” `s` 的值。如果想要获取 `s` 的拷贝，我们需要显式调用 `.clone()` 方法，而不是直接解引用。